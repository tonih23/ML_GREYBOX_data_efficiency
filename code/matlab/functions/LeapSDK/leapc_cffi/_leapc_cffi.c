#define _CFFI_

/* We try to define Py_LIMITED_API before including Python.h.

   Mess: we can only define it if Py_DEBUG, Py_TRACE_REFS and
   Py_REF_DEBUG are not defined.  This is a best-effort approximation:
   we can learn about Py_DEBUG from pyconfig.h, but it is unclear if
   the same works for the other two macros.  Py_DEBUG implies them,
   but not the other way around.

   The implementation is messy (issue #350): on Windows, with _MSC_VER,
   we have to define Py_LIMITED_API even before including pyconfig.h.
   In that case, we guess what pyconfig.h will do to the macros above,
   and check our guess after the #include.

   Note that on Windows, with CPython 3.x, you need >= 3.5 and virtualenv
   version >= 16.0.0.  With older versions of either, you don't get a
   copy of PYTHON3.DLL in the virtualenv.  We can't check the version of
   CPython *before* we even include pyconfig.h.  ffi.set_source() puts
   a ``#define _CFFI_NO_LIMITED_API'' at the start of this file if it is
   running on Windows < 3.5, as an attempt at fixing it, but that's
   arguably wrong because it may not be the target version of Python.
   Still better than nothing I guess.  As another workaround, you can
   remove the definition of Py_LIMITED_API here.

   See also 'py_limited_api' in cffi/setuptools_ext.py.
*/
#if !defined(_CFFI_USE_EMBEDDING) && !defined(Py_LIMITED_API)
#  ifdef _MSC_VER
#    if !defined(_DEBUG) && !defined(Py_DEBUG) && !defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG) && !defined(_CFFI_NO_LIMITED_API)
#      define Py_LIMITED_API
#    endif
#    include <pyconfig.h>
     /* sanity-check: Py_LIMITED_API will cause crashes if any of these
        are also defined.  Normally, the Python file PC/pyconfig.h does not
        cause any of these to be defined, with the exception that _DEBUG
        causes Py_DEBUG.  Double-check that. */
#    ifdef Py_LIMITED_API
#      if defined(Py_DEBUG)
#        error "pyconfig.h unexpectedly defines Py_DEBUG, but Py_LIMITED_API is set"
#      endif
#      if defined(Py_TRACE_REFS)
#        error "pyconfig.h unexpectedly defines Py_TRACE_REFS, but Py_LIMITED_API is set"
#      endif
#      if defined(Py_REF_DEBUG)
#        error "pyconfig.h unexpectedly defines Py_REF_DEBUG, but Py_LIMITED_API is set"
#      endif
#    endif
#  else
#    include <pyconfig.h>
#    if !defined(Py_DEBUG) && !defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG) && !defined(_CFFI_NO_LIMITED_API)
#      define Py_LIMITED_API
#    endif
#  endif
#endif

#include <Python.h>
#ifdef __cplusplus
extern "C" {
#endif
#include <stddef.h>

/* This part is from file 'cffi/parse_c_type.h'.  It is copied at the
   beginning of C sources generated by CFFI's ffi.set_source(). */

typedef void *_cffi_opcode_t;

#define _CFFI_OP(opcode, arg)   (_cffi_opcode_t)(opcode | (((uintptr_t)(arg)) << 8))
#define _CFFI_GETOP(cffi_opcode)    ((unsigned char)(uintptr_t)cffi_opcode)
#define _CFFI_GETARG(cffi_opcode)   (((intptr_t)cffi_opcode) >> 8)

#define _CFFI_OP_PRIMITIVE       1
#define _CFFI_OP_POINTER         3
#define _CFFI_OP_ARRAY           5
#define _CFFI_OP_OPEN_ARRAY      7
#define _CFFI_OP_STRUCT_UNION    9
#define _CFFI_OP_ENUM           11
#define _CFFI_OP_FUNCTION       13
#define _CFFI_OP_FUNCTION_END   15
#define _CFFI_OP_NOOP           17
#define _CFFI_OP_BITFIELD       19
#define _CFFI_OP_TYPENAME       21
#define _CFFI_OP_CPYTHON_BLTN_V 23   // varargs
#define _CFFI_OP_CPYTHON_BLTN_N 25   // noargs
#define _CFFI_OP_CPYTHON_BLTN_O 27   // O  (i.e. a single arg)
#define _CFFI_OP_CONSTANT       29
#define _CFFI_OP_CONSTANT_INT   31
#define _CFFI_OP_GLOBAL_VAR     33
#define _CFFI_OP_DLOPEN_FUNC    35
#define _CFFI_OP_DLOPEN_CONST   37
#define _CFFI_OP_GLOBAL_VAR_F   39
#define _CFFI_OP_EXTERN_PYTHON  41

#define _CFFI_PRIM_VOID          0
#define _CFFI_PRIM_BOOL          1
#define _CFFI_PRIM_CHAR          2
#define _CFFI_PRIM_SCHAR         3
#define _CFFI_PRIM_UCHAR         4
#define _CFFI_PRIM_SHORT         5
#define _CFFI_PRIM_USHORT        6
#define _CFFI_PRIM_INT           7
#define _CFFI_PRIM_UINT          8
#define _CFFI_PRIM_LONG          9
#define _CFFI_PRIM_ULONG        10
#define _CFFI_PRIM_LONGLONG     11
#define _CFFI_PRIM_ULONGLONG    12
#define _CFFI_PRIM_FLOAT        13
#define _CFFI_PRIM_DOUBLE       14
#define _CFFI_PRIM_LONGDOUBLE   15

#define _CFFI_PRIM_WCHAR        16
#define _CFFI_PRIM_INT8         17
#define _CFFI_PRIM_UINT8        18
#define _CFFI_PRIM_INT16        19
#define _CFFI_PRIM_UINT16       20
#define _CFFI_PRIM_INT32        21
#define _CFFI_PRIM_UINT32       22
#define _CFFI_PRIM_INT64        23
#define _CFFI_PRIM_UINT64       24
#define _CFFI_PRIM_INTPTR       25
#define _CFFI_PRIM_UINTPTR      26
#define _CFFI_PRIM_PTRDIFF      27
#define _CFFI_PRIM_SIZE         28
#define _CFFI_PRIM_SSIZE        29
#define _CFFI_PRIM_INT_LEAST8   30
#define _CFFI_PRIM_UINT_LEAST8  31
#define _CFFI_PRIM_INT_LEAST16  32
#define _CFFI_PRIM_UINT_LEAST16 33
#define _CFFI_PRIM_INT_LEAST32  34
#define _CFFI_PRIM_UINT_LEAST32 35
#define _CFFI_PRIM_INT_LEAST64  36
#define _CFFI_PRIM_UINT_LEAST64 37
#define _CFFI_PRIM_INT_FAST8    38
#define _CFFI_PRIM_UINT_FAST8   39
#define _CFFI_PRIM_INT_FAST16   40
#define _CFFI_PRIM_UINT_FAST16  41
#define _CFFI_PRIM_INT_FAST32   42
#define _CFFI_PRIM_UINT_FAST32  43
#define _CFFI_PRIM_INT_FAST64   44
#define _CFFI_PRIM_UINT_FAST64  45
#define _CFFI_PRIM_INTMAX       46
#define _CFFI_PRIM_UINTMAX      47
#define _CFFI_PRIM_FLOATCOMPLEX 48
#define _CFFI_PRIM_DOUBLECOMPLEX 49
#define _CFFI_PRIM_CHAR16       50
#define _CFFI_PRIM_CHAR32       51

#define _CFFI__NUM_PRIM         52
#define _CFFI__UNKNOWN_PRIM           (-1)
#define _CFFI__UNKNOWN_FLOAT_PRIM     (-2)
#define _CFFI__UNKNOWN_LONG_DOUBLE    (-3)

#define _CFFI__IO_FILE_STRUCT         (-1)


struct _cffi_global_s {
    const char *name;
    void *address;
    _cffi_opcode_t type_op;
    void *size_or_direct_fn;  // OP_GLOBAL_VAR: size, or 0 if unknown
                              // OP_CPYTHON_BLTN_*: addr of direct function
};

struct _cffi_getconst_s {
    unsigned long long value;
    const struct _cffi_type_context_s *ctx;
    int gindex;
};

struct _cffi_struct_union_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_STRUCT_UNION
    int flags;               // _CFFI_F_* flags below
    size_t size;
    int alignment;
    int first_field_index;   // -> _cffi_fields array
    int num_fields;
};
#define _CFFI_F_UNION         0x01   // is a union, not a struct
#define _CFFI_F_CHECK_FIELDS  0x02   // complain if fields are not in the
                                     // "standard layout" or if some are missing
#define _CFFI_F_PACKED        0x04   // for CHECK_FIELDS, assume a packed struct
#define _CFFI_F_EXTERNAL      0x08   // in some other ffi.include()
#define _CFFI_F_OPAQUE        0x10   // opaque

struct _cffi_field_s {
    const char *name;
    size_t field_offset;
    size_t field_size;
    _cffi_opcode_t field_type_op;
};

struct _cffi_enum_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_ENUM
    int type_prim;           // _CFFI_PRIM_xxx
    const char *enumerators; // comma-delimited string
};

struct _cffi_typename_s {
    const char *name;
    int type_index;   /* if opaque, points to a possibly artificial
                         OP_STRUCT which is itself opaque */
};

struct _cffi_type_context_s {
    _cffi_opcode_t *types;
    const struct _cffi_global_s *globals;
    const struct _cffi_field_s *fields;
    const struct _cffi_struct_union_s *struct_unions;
    const struct _cffi_enum_s *enums;
    const struct _cffi_typename_s *typenames;
    int num_globals;
    int num_struct_unions;
    int num_enums;
    int num_typenames;
    const char *const *includes;
    int num_types;
    int flags;      /* future extension */
};

struct _cffi_parse_info_s {
    const struct _cffi_type_context_s *ctx;
    _cffi_opcode_t *output;
    unsigned int output_size;
    size_t error_location;
    const char *error_message;
};

struct _cffi_externpy_s {
    const char *name;
    size_t size_of_result;
    void *reserved1, *reserved2;
};

#ifdef _CFFI_INTERNAL
static int parse_c_type(struct _cffi_parse_info_s *info, const char *input);
static int search_in_globals(const struct _cffi_type_context_s *ctx,
                             const char *search, size_t search_len);
static int search_in_struct_unions(const struct _cffi_type_context_s *ctx,
                                   const char *search, size_t search_len);
#endif

/* this block of #ifs should be kept exactly identical between
   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py
   and cffi/_cffi_include.h */
#if defined(_MSC_VER)
# include <malloc.h>   /* for alloca() */
# if _MSC_VER < 1600   /* MSVC < 2010 */
   typedef __int8 int8_t;
   typedef __int16 int16_t;
   typedef __int32 int32_t;
   typedef __int64 int64_t;
   typedef unsigned __int8 uint8_t;
   typedef unsigned __int16 uint16_t;
   typedef unsigned __int32 uint32_t;
   typedef unsigned __int64 uint64_t;
   typedef __int8 int_least8_t;
   typedef __int16 int_least16_t;
   typedef __int32 int_least32_t;
   typedef __int64 int_least64_t;
   typedef unsigned __int8 uint_least8_t;
   typedef unsigned __int16 uint_least16_t;
   typedef unsigned __int32 uint_least32_t;
   typedef unsigned __int64 uint_least64_t;
   typedef __int8 int_fast8_t;
   typedef __int16 int_fast16_t;
   typedef __int32 int_fast32_t;
   typedef __int64 int_fast64_t;
   typedef unsigned __int8 uint_fast8_t;
   typedef unsigned __int16 uint_fast16_t;
   typedef unsigned __int32 uint_fast32_t;
   typedef unsigned __int64 uint_fast64_t;
   typedef __int64 intmax_t;
   typedef unsigned __int64 uintmax_t;
# else
#  include <stdint.h>
# endif
# if _MSC_VER < 1800   /* MSVC < 2013 */
#  ifndef __cplusplus
    typedef unsigned char _Bool;
#  endif
# endif
#else
# include <stdint.h>
# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)
#  include <alloca.h>
# endif
#endif

#ifdef __GNUC__
# define _CFFI_UNUSED_FN  __attribute__((unused))
#else
# define _CFFI_UNUSED_FN  /* nothing */
#endif

#ifdef __cplusplus
# ifndef _Bool
   typedef bool _Bool;   /* semi-hackish: C++ has no _Bool; bool is builtin */
# endif
#endif

/**********  CPython-specific section  **********/
#ifndef PYPY_VERSION


#if PY_MAJOR_VERSION >= 3
# define PyInt_FromLong PyLong_FromLong
#endif

#define _cffi_from_c_double PyFloat_FromDouble
#define _cffi_from_c_float PyFloat_FromDouble
#define _cffi_from_c_long PyInt_FromLong
#define _cffi_from_c_ulong PyLong_FromUnsignedLong
#define _cffi_from_c_longlong PyLong_FromLongLong
#define _cffi_from_c_ulonglong PyLong_FromUnsignedLongLong
#define _cffi_from_c__Bool PyBool_FromLong

#define _cffi_to_c_double PyFloat_AsDouble
#define _cffi_to_c_float PyFloat_AsDouble

#define _cffi_from_c_int(x, type)                                        \
    (((type)-1) > 0 ? /* unsigned */                                     \
        (sizeof(type) < sizeof(long) ?                                   \
            PyInt_FromLong((long)x) :                                    \
         sizeof(type) == sizeof(long) ?                                  \
            PyLong_FromUnsignedLong((unsigned long)x) :                  \
            PyLong_FromUnsignedLongLong((unsigned long long)x)) :        \
        (sizeof(type) <= sizeof(long) ?                                  \
            PyInt_FromLong((long)x) :                                    \
            PyLong_FromLongLong((long long)x)))

#define _cffi_to_c_int(o, type)                                          \
    ((type)(                                                             \
     sizeof(type) == 1 ? (((type)-1) > 0 ? (type)_cffi_to_c_u8(o)        \
                                         : (type)_cffi_to_c_i8(o)) :     \
     sizeof(type) == 2 ? (((type)-1) > 0 ? (type)_cffi_to_c_u16(o)       \
                                         : (type)_cffi_to_c_i16(o)) :    \
     sizeof(type) == 4 ? (((type)-1) > 0 ? (type)_cffi_to_c_u32(o)       \
                                         : (type)_cffi_to_c_i32(o)) :    \
     sizeof(type) == 8 ? (((type)-1) > 0 ? (type)_cffi_to_c_u64(o)       \
                                         : (type)_cffi_to_c_i64(o)) :    \
     (Py_FatalError("unsupported size for type " #type), (type)0)))

#define _cffi_to_c_i8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[1])
#define _cffi_to_c_u8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[2])
#define _cffi_to_c_i16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[3])
#define _cffi_to_c_u16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[4])
#define _cffi_to_c_i32                                                   \
                 ((int(*)(PyObject *))_cffi_exports[5])
#define _cffi_to_c_u32                                                   \
                 ((unsigned int(*)(PyObject *))_cffi_exports[6])
#define _cffi_to_c_i64                                                   \
                 ((long long(*)(PyObject *))_cffi_exports[7])
#define _cffi_to_c_u64                                                   \
                 ((unsigned long long(*)(PyObject *))_cffi_exports[8])
#define _cffi_to_c_char                                                  \
                 ((int(*)(PyObject *))_cffi_exports[9])
#define _cffi_from_c_pointer                                             \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[10])
#define _cffi_to_c_pointer                                               \
    ((char *(*)(PyObject *, struct _cffi_ctypedescr *))_cffi_exports[11])
#define _cffi_get_struct_layout                                          \
    not used any more
#define _cffi_restore_errno                                              \
    ((void(*)(void))_cffi_exports[13])
#define _cffi_save_errno                                                 \
    ((void(*)(void))_cffi_exports[14])
#define _cffi_from_c_char                                                \
    ((PyObject *(*)(char))_cffi_exports[15])
#define _cffi_from_c_deref                                               \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[16])
#define _cffi_to_c                                                       \
    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[17])
#define _cffi_from_c_struct                                              \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[18])
#define _cffi_to_c_wchar_t                                               \
    ((_cffi_wchar_t(*)(PyObject *))_cffi_exports[19])
#define _cffi_from_c_wchar_t                                             \
    ((PyObject *(*)(_cffi_wchar_t))_cffi_exports[20])
#define _cffi_to_c_long_double                                           \
    ((long double(*)(PyObject *))_cffi_exports[21])
#define _cffi_to_c__Bool                                                 \
    ((_Bool(*)(PyObject *))_cffi_exports[22])
#define _cffi_prepare_pointer_call_argument                              \
    ((Py_ssize_t(*)(struct _cffi_ctypedescr *,                           \
                    PyObject *, char **))_cffi_exports[23])
#define _cffi_convert_array_from_object                                  \
    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[24])
#define _CFFI_CPIDX  25
#define _cffi_call_python                                                \
    ((void(*)(struct _cffi_externpy_s *, char *))_cffi_exports[_CFFI_CPIDX])
#define _cffi_to_c_wchar3216_t                                           \
    ((int(*)(PyObject *))_cffi_exports[26])
#define _cffi_from_c_wchar3216_t                                         \
    ((PyObject *(*)(int))_cffi_exports[27])
#define _CFFI_NUM_EXPORTS 28

struct _cffi_ctypedescr;

static void *_cffi_exports[_CFFI_NUM_EXPORTS];

#define _cffi_type(index)   (                           \
    assert((((uintptr_t)_cffi_types[index]) & 1) == 0), \
    (struct _cffi_ctypedescr *)_cffi_types[index])

static PyObject *_cffi_init(const char *module_name, Py_ssize_t version,
                            const struct _cffi_type_context_s *ctx)
{
    PyObject *module, *o_arg, *new_module;
    void *raw[] = {
        (void *)module_name,
        (void *)version,
        (void *)_cffi_exports,
        (void *)ctx,
    };

    module = PyImport_ImportModule("_cffi_backend");
    if (module == NULL)
        goto failure;

    o_arg = PyLong_FromVoidPtr((void *)raw);
    if (o_arg == NULL)
        goto failure;

    new_module = PyObject_CallMethod(
        module, (char *)"_init_cffi_1_0_external_module", (char *)"O", o_arg);

    Py_DECREF(o_arg);
    Py_DECREF(module);
    return new_module;

  failure:
    Py_XDECREF(module);
    return NULL;
}


#ifdef HAVE_WCHAR_H
typedef wchar_t _cffi_wchar_t;
#else
typedef uint16_t _cffi_wchar_t;   /* same random pick as _cffi_backend.c */
#endif

_CFFI_UNUSED_FN static uint16_t _cffi_to_c_char16_t(PyObject *o)
{
    if (sizeof(_cffi_wchar_t) == 2)
        return (uint16_t)_cffi_to_c_wchar_t(o);
    else
        return (uint16_t)_cffi_to_c_wchar3216_t(o);
}

_CFFI_UNUSED_FN static PyObject *_cffi_from_c_char16_t(uint16_t x)
{
    if (sizeof(_cffi_wchar_t) == 2)
        return _cffi_from_c_wchar_t((_cffi_wchar_t)x);
    else
        return _cffi_from_c_wchar3216_t((int)x);
}

_CFFI_UNUSED_FN static int _cffi_to_c_char32_t(PyObject *o)
{
    if (sizeof(_cffi_wchar_t) == 4)
        return (int)_cffi_to_c_wchar_t(o);
    else
        return (int)_cffi_to_c_wchar3216_t(o);
}

_CFFI_UNUSED_FN static PyObject *_cffi_from_c_char32_t(unsigned int x)
{
    if (sizeof(_cffi_wchar_t) == 4)
        return _cffi_from_c_wchar_t((_cffi_wchar_t)x);
    else
        return _cffi_from_c_wchar3216_t((int)x);
}

union _cffi_union_alignment_u {
    unsigned char m_char;
    unsigned short m_short;
    unsigned int m_int;
    unsigned long m_long;
    unsigned long long m_longlong;
    float m_float;
    double m_double;
    long double m_longdouble;
};

struct _cffi_freeme_s {
    struct _cffi_freeme_s *next;
    union _cffi_union_alignment_u alignment;
};

_CFFI_UNUSED_FN static int
_cffi_convert_array_argument(struct _cffi_ctypedescr *ctptr, PyObject *arg,
                             char **output_data, Py_ssize_t datasize,
                             struct _cffi_freeme_s **freeme)
{
    char *p;
    if (datasize < 0)
        return -1;

    p = *output_data;
    if (p == NULL) {
        struct _cffi_freeme_s *fp = (struct _cffi_freeme_s *)PyObject_Malloc(
            offsetof(struct _cffi_freeme_s, alignment) + (size_t)datasize);
        if (fp == NULL)
            return -1;
        fp->next = *freeme;
        *freeme = fp;
        p = *output_data = (char *)&fp->alignment;
    }
    memset((void *)p, 0, (size_t)datasize);
    return _cffi_convert_array_from_object(p, ctptr, arg);
}

_CFFI_UNUSED_FN static void
_cffi_free_array_arguments(struct _cffi_freeme_s *freeme)
{
    do {
        void *p = (void *)freeme;
        freeme = freeme->next;
        PyObject_Free(p);
    } while (freeme != NULL);
}

/**********  end CPython-specific section  **********/
#else
_CFFI_UNUSED_FN
static void (*_cffi_call_python_org)(struct _cffi_externpy_s *, char *);
# define _cffi_call_python  _cffi_call_python_org
#endif


#define _cffi_array_len(array)   (sizeof(array) / sizeof((array)[0]))

#define _cffi_prim_int(size, sign)                                      \
    ((size) == 1 ? ((sign) ? _CFFI_PRIM_INT8  : _CFFI_PRIM_UINT8)  :    \
     (size) == 2 ? ((sign) ? _CFFI_PRIM_INT16 : _CFFI_PRIM_UINT16) :    \
     (size) == 4 ? ((sign) ? _CFFI_PRIM_INT32 : _CFFI_PRIM_UINT32) :    \
     (size) == 8 ? ((sign) ? _CFFI_PRIM_INT64 : _CFFI_PRIM_UINT64) :    \
     _CFFI__UNKNOWN_PRIM)

#define _cffi_prim_float(size)                                          \
    ((size) == sizeof(float) ? _CFFI_PRIM_FLOAT :                       \
     (size) == sizeof(double) ? _CFFI_PRIM_DOUBLE :                     \
     (size) == sizeof(long double) ? _CFFI__UNKNOWN_LONG_DOUBLE :       \
     _CFFI__UNKNOWN_FLOAT_PRIM)

#define _cffi_check_int(got, got_nonpos, expected)      \
    ((got_nonpos) == (expected <= 0) &&                 \
     (got) == (unsigned long long)expected)

#ifdef MS_WIN32
# define _cffi_stdcall  __stdcall
#else
# define _cffi_stdcall  /* nothing */
#endif

#ifdef __cplusplus
}
#endif

/************************************************************/

#include "LeapC.h"


/************************************************************/

static void *_cffi_types[] = {
/*  0 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3), // LEAP_VECTOR()(struct _LEAP_CONNECTION *, eLeapPerspectiveType, LEAP_VECTOR)
/*  1 */ _CFFI_OP(_CFFI_OP_POINTER, 408), // struct _LEAP_CONNECTION *
/*  2 */ _CFFI_OP(_CFFI_OP_ENUM, 13), // eLeapPerspectiveType
/*  3 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 49), // LEAP_VECTOR
/*  4 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/*  5 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3), // LEAP_VECTOR()(struct _LEAP_CONNECTION *, struct _LEAP_DEVICE *, eLeapPerspectiveType, LEAP_VECTOR)
/*  6 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/*  7 */ _CFFI_OP(_CFFI_OP_POINTER, 409), // struct _LEAP_DEVICE *
/*  8 */ _CFFI_OP(_CFFI_OP_NOOP, 2),
/*  9 */ _CFFI_OP(_CFFI_OP_NOOP, 3),
/* 10 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 11 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3), // LEAP_VECTOR()(struct _LEAP_CONNECTION *, struct _LEAP_DEVICE *, uint8_t, LEAP_VECTOR)
/* 12 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 13 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 14 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 18), // uint8_t
/* 15 */ _CFFI_OP(_CFFI_OP_NOOP, 3),
/* 16 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 17 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3), // LEAP_VECTOR()(struct _LEAP_CONNECTION *, uint8_t, LEAP_VECTOR)
/* 18 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 19 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 18),
/* 20 */ _CFFI_OP(_CFFI_OP_NOOP, 3),
/* 21 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 22 */ _CFFI_OP(_CFFI_OP_FUNCTION, 79), // _Bool()(struct _LEAP_DEVICE *)
/* 23 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 24 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 25 */ _CFFI_OP(_CFFI_OP_FUNCTION, 83), // char const *()(eLeapDevicePID)
/* 26 */ _CFFI_OP(_CFFI_OP_ENUM, 4), // eLeapDevicePID
/* 27 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 28 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(LEAP_CONNECTION_CONFIG const *, struct _LEAP_CONNECTION * *)
/* 29 */ _CFFI_OP(_CFFI_OP_POINTER, 308), // LEAP_CONNECTION_CONFIG const *
/* 30 */ _CFFI_OP(_CFFI_OP_POINTER, 1), // struct _LEAP_CONNECTION * *
/* 31 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 32 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(LEAP_DEVICE_REF, struct _LEAP_DEVICE * *)
/* 33 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 17), // LEAP_DEVICE_REF
/* 34 */ _CFFI_OP(_CFFI_OP_POINTER, 7), // struct _LEAP_DEVICE * *
/* 35 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 36 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(LEAP_SERVER_STATUS const *)
/* 37 */ _CFFI_OP(_CFFI_OP_POINTER, 361), // LEAP_SERVER_STATUS const *
/* 38 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 39 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CLOCK_REBASER * *)
/* 40 */ _CFFI_OP(_CFFI_OP_POINTER, 43), // struct _LEAP_CLOCK_REBASER * *
/* 41 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 42 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CLOCK_REBASER *, int64_t, int64_t *)
/* 43 */ _CFFI_OP(_CFFI_OP_POINTER, 407), // struct _LEAP_CLOCK_REBASER *
/* 44 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23), // int64_t
/* 45 */ _CFFI_OP(_CFFI_OP_POINTER, 44), // int64_t *
/* 46 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 47 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CLOCK_REBASER *, int64_t, int64_t)
/* 48 */ _CFFI_OP(_CFFI_OP_NOOP, 43),
/* 49 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 50 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 51 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 52 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *)
/* 53 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 54 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 55 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, LEAP_ALLOCATOR const *)
/* 56 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 57 */ _CFFI_OP(_CFFI_OP_POINTER, 300), // LEAP_ALLOCATOR const *
/* 58 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 59 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, LEAP_CONNECTION_INFO *)
/* 60 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 61 */ _CFFI_OP(_CFFI_OP_POINTER, 311), // LEAP_CONNECTION_INFO *
/* 62 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 63 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, LEAP_DEVICE_REF *, uint32_t *)
/* 64 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 65 */ _CFFI_OP(_CFFI_OP_POINTER, 33), // LEAP_DEVICE_REF *
/* 66 */ _CFFI_OP(_CFFI_OP_POINTER, 202), // uint32_t *
/* 67 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 68 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, LEAP_POINT_MAPPING *, uint64_t *)
/* 69 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 70 */ _CFFI_OP(_CFFI_OP_POINTER, 354), // LEAP_POINT_MAPPING *
/* 71 */ _CFFI_OP(_CFFI_OP_POINTER, 129), // uint64_t *
/* 72 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 73 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, LEAP_TELEMETRY_DATA const *)
/* 74 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 75 */ _CFFI_OP(_CFFI_OP_POINTER, 364), // LEAP_TELEMETRY_DATA const *
/* 76 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 77 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, _Bool)
/* 78 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 79 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 1), // _Bool
/* 80 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 81 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, char const *, LEAP_VARIANT const *, uint32_t *)
/* 82 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 83 */ _CFFI_OP(_CFFI_OP_POINTER, 375), // char const *
/* 84 */ _CFFI_OP(_CFFI_OP_POINTER, 369), // LEAP_VARIANT const *
/* 85 */ _CFFI_OP(_CFFI_OP_NOOP, 66),
/* 86 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 87 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, char const *, _Bool *)
/* 88 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 89 */ _CFFI_OP(_CFFI_OP_NOOP, 83),
/* 90 */ _CFFI_OP(_CFFI_OP_POINTER, 79), // _Bool *
/* 91 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 92 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, char const *, size_t)
/* 93 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 94 */ _CFFI_OP(_CFFI_OP_NOOP, 83),
/* 95 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28), // size_t
/* 96 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 97 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, char const *, uint32_t *)
/* 98 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 99 */ _CFFI_OP(_CFFI_OP_NOOP, 83),
/* 100 */ _CFFI_OP(_CFFI_OP_NOOP, 66),
/* 101 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 102 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, eLeapTrackingMode)
/* 103 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 104 */ _CFFI_OP(_CFFI_OP_ENUM, 18), // eLeapTrackingMode
/* 105 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 106 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, eLeapVersionPart, LEAP_VERSION *)
/* 107 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 108 */ _CFFI_OP(_CFFI_OP_ENUM, 21), // eLeapVersionPart
/* 109 */ _CFFI_OP(_CFFI_OP_POINTER, 373), // LEAP_VERSION *
/* 110 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 111 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, float *)
/* 112 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 113 */ _CFFI_OP(_CFFI_OP_POINTER, 394), // float *
/* 114 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 115 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, int64_t, LEAP_EYE_EVENT *)
/* 116 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 117 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 118 */ _CFFI_OP(_CFFI_OP_POINTER, 330), // LEAP_EYE_EVENT *
/* 119 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 120 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, int64_t, LEAP_HEAD_POSE_EVENT *)
/* 121 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 122 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 123 */ _CFFI_OP(_CFFI_OP_POINTER, 335), // LEAP_HEAD_POSE_EVENT *
/* 124 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 125 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, int64_t, LEAP_TRACKING_EVENT *, uint64_t)
/* 126 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 127 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 128 */ _CFFI_OP(_CFFI_OP_POINTER, 366), // LEAP_TRACKING_EVENT *
/* 129 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24), // uint64_t
/* 130 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 131 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, int64_t, int64_t, LEAP_TRACKING_EVENT *, uint64_t)
/* 132 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 133 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 134 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 135 */ _CFFI_OP(_CFFI_OP_NOOP, 128),
/* 136 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24),
/* 137 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 138 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, int64_t, uint64_t *)
/* 139 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 140 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 141 */ _CFFI_OP(_CFFI_OP_NOOP, 71),
/* 142 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 143 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, struct _LEAP_DEVICE *)
/* 144 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 145 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 146 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 147 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, struct _LEAP_DEVICE *, _Bool)
/* 148 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 149 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 150 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 1),
/* 151 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 152 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, struct _LEAP_DEVICE *, char const * *)
/* 153 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 154 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 155 */ _CFFI_OP(_CFFI_OP_POINTER, 83), // char const * *
/* 156 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 157 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, struct _LEAP_DEVICE *, eLeapTrackingMode)
/* 158 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 159 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 160 */ _CFFI_OP(_CFFI_OP_NOOP, 104),
/* 161 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 162 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, struct _LEAP_DEVICE *, float *)
/* 163 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 164 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 165 */ _CFFI_OP(_CFFI_OP_NOOP, 113),
/* 166 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 167 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, struct _LEAP_DEVICE *, int64_t, LEAP_HEAD_POSE_EVENT *)
/* 168 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 169 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 170 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 171 */ _CFFI_OP(_CFFI_OP_NOOP, 123),
/* 172 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 173 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, struct _LEAP_DEVICE *, int64_t, LEAP_TRACKING_EVENT *, uint64_t)
/* 174 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 175 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 176 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 177 */ _CFFI_OP(_CFFI_OP_NOOP, 128),
/* 178 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24),
/* 179 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 180 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, struct _LEAP_DEVICE *, int64_t, int64_t, LEAP_TRACKING_EVENT *, uint64_t)
/* 181 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 182 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 183 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 184 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 185 */ _CFFI_OP(_CFFI_OP_NOOP, 128),
/* 186 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24),
/* 187 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 188 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, struct _LEAP_DEVICE *, int64_t, uint64_t *)
/* 189 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 190 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 191 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 192 */ _CFFI_OP(_CFFI_OP_NOOP, 71),
/* 193 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 194 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, struct _LEAP_DEVICE *, uint64_t, uint64_t)
/* 195 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 196 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 197 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24),
/* 198 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24),
/* 199 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 200 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, uint32_t, LEAP_CONNECTION_MESSAGE *)
/* 201 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 202 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 22), // uint32_t
/* 203 */ _CFFI_OP(_CFFI_OP_POINTER, 314), // LEAP_CONNECTION_MESSAGE *
/* 204 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 205 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, uint64_t *)
/* 206 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 207 */ _CFFI_OP(_CFFI_OP_NOOP, 71),
/* 208 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 209 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_CONNECTION *, uint64_t, uint64_t)
/* 210 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 211 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24),
/* 212 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24),
/* 213 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 214 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_DEVICE *, LEAP_DEVICE_INFO *)
/* 215 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 216 */ _CFFI_OP(_CFFI_OP_POINTER, 319), // LEAP_DEVICE_INFO *
/* 217 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 218 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_DEVICE *, float *)
/* 219 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 220 */ _CFFI_OP(_CFFI_OP_NOOP, 113),
/* 221 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 222 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_DEVICE *, uint8_t *)
/* 223 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 224 */ _CFFI_OP(_CFFI_OP_POINTER, 14), // uint8_t *
/* 225 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 226 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_RECORDING * *)
/* 227 */ _CFFI_OP(_CFFI_OP_POINTER, 235), // struct _LEAP_RECORDING * *
/* 228 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 229 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_RECORDING * *, char const *, LEAP_RECORDING_PARAMETERS)
/* 230 */ _CFFI_OP(_CFFI_OP_NOOP, 227),
/* 231 */ _CFFI_OP(_CFFI_OP_NOOP, 83),
/* 232 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 41), // LEAP_RECORDING_PARAMETERS
/* 233 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 234 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_RECORDING *, LEAP_RECORDING_STATUS *)
/* 235 */ _CFFI_OP(_CFFI_OP_POINTER, 410), // struct _LEAP_RECORDING *
/* 236 */ _CFFI_OP(_CFFI_OP_POINTER, 360), // LEAP_RECORDING_STATUS *
/* 237 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 238 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_RECORDING *, LEAP_TRACKING_EVENT *, uint64_t *)
/* 239 */ _CFFI_OP(_CFFI_OP_NOOP, 235),
/* 240 */ _CFFI_OP(_CFFI_OP_NOOP, 128),
/* 241 */ _CFFI_OP(_CFFI_OP_NOOP, 71),
/* 242 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 243 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_RECORDING *, LEAP_TRACKING_EVENT *, uint64_t)
/* 244 */ _CFFI_OP(_CFFI_OP_NOOP, 235),
/* 245 */ _CFFI_OP(_CFFI_OP_NOOP, 128),
/* 246 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24),
/* 247 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 248 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(struct _LEAP_RECORDING *, uint64_t *)
/* 249 */ _CFFI_OP(_CFFI_OP_NOOP, 235),
/* 250 */ _CFFI_OP(_CFFI_OP_NOOP, 71),
/* 251 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 252 */ _CFFI_OP(_CFFI_OP_FUNCTION, 388), // eLeapRS()(uint32_t, LEAP_SERVER_STATUS const * *)
/* 253 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 22),
/* 254 */ _CFFI_OP(_CFFI_OP_POINTER, 37), // LEAP_SERVER_STATUS const * *
/* 255 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 256 */ _CFFI_OP(_CFFI_OP_FUNCTION, 44), // int64_t()(void)
/* 257 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 258 */ _CFFI_OP(_CFFI_OP_FUNCTION, 129), // uint64_t()(void)
/* 259 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 260 */ _CFFI_OP(_CFFI_OP_FUNCTION, 263), // void *()(uint32_t, eLeapAllocatorType, void *)
/* 261 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 22),
/* 262 */ _CFFI_OP(_CFFI_OP_ENUM, 0), // eLeapAllocatorType
/* 263 */ _CFFI_OP(_CFFI_OP_POINTER, 414), // void *
/* 264 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 265 */ _CFFI_OP(_CFFI_OP_FUNCTION, 414), // void()(struct _LEAP_CLOCK_REBASER *)
/* 266 */ _CFFI_OP(_CFFI_OP_NOOP, 43),
/* 267 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 268 */ _CFFI_OP(_CFFI_OP_FUNCTION, 414), // void()(struct _LEAP_CONNECTION *)
/* 269 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 270 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 271 */ _CFFI_OP(_CFFI_OP_FUNCTION, 414), // void()(struct _LEAP_CONNECTION *, eLeapPerspectiveType, float *)
/* 272 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 273 */ _CFFI_OP(_CFFI_OP_NOOP, 2),
/* 274 */ _CFFI_OP(_CFFI_OP_NOOP, 113),
/* 275 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 276 */ _CFFI_OP(_CFFI_OP_FUNCTION, 414), // void()(struct _LEAP_CONNECTION *, struct _LEAP_DEVICE *, eLeapPerspectiveType, float *)
/* 277 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 278 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 279 */ _CFFI_OP(_CFFI_OP_NOOP, 2),
/* 280 */ _CFFI_OP(_CFFI_OP_NOOP, 113),
/* 281 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 282 */ _CFFI_OP(_CFFI_OP_FUNCTION, 414), // void()(struct _LEAP_CONNECTION *, struct _LEAP_DEVICE *, uint8_t, float *)
/* 283 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 284 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 285 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 18),
/* 286 */ _CFFI_OP(_CFFI_OP_NOOP, 113),
/* 287 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 288 */ _CFFI_OP(_CFFI_OP_FUNCTION, 414), // void()(struct _LEAP_CONNECTION *, uint8_t, float *)
/* 289 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 290 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 18),
/* 291 */ _CFFI_OP(_CFFI_OP_NOOP, 113),
/* 292 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 293 */ _CFFI_OP(_CFFI_OP_FUNCTION, 414), // void()(struct _LEAP_DEVICE *)
/* 294 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 295 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 296 */ _CFFI_OP(_CFFI_OP_FUNCTION, 414), // void()(void *, void *)
/* 297 */ _CFFI_OP(_CFFI_OP_NOOP, 263),
/* 298 */ _CFFI_OP(_CFFI_OP_NOOP, 263),
/* 299 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 300 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 1), // LEAP_ALLOCATOR
/* 301 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 2), // LEAP_BONE
/* 302 */ _CFFI_OP(_CFFI_OP_ARRAY, 301), // LEAP_BONE[4]
/* 303 */ (_cffi_opcode_t)(4),
/* 304 */ _CFFI_OP(_CFFI_OP_POINTER, 305), // LEAP_CONFIG_CHANGE_EVENT const *
/* 305 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 5), // LEAP_CONFIG_CHANGE_EVENT
/* 306 */ _CFFI_OP(_CFFI_OP_POINTER, 307), // LEAP_CONFIG_RESPONSE_EVENT const *
/* 307 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 6), // LEAP_CONFIG_RESPONSE_EVENT
/* 308 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 8), // LEAP_CONNECTION_CONFIG
/* 309 */ _CFFI_OP(_CFFI_OP_POINTER, 310), // LEAP_CONNECTION_EVENT const *
/* 310 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 9), // LEAP_CONNECTION_EVENT
/* 311 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 10), // LEAP_CONNECTION_INFO
/* 312 */ _CFFI_OP(_CFFI_OP_POINTER, 313), // LEAP_CONNECTION_LOST_EVENT const *
/* 313 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 11), // LEAP_CONNECTION_LOST_EVENT
/* 314 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 12), // LEAP_CONNECTION_MESSAGE
/* 315 */ _CFFI_OP(_CFFI_OP_POINTER, 316), // LEAP_DEVICE_EVENT const *
/* 316 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 14), // LEAP_DEVICE_EVENT
/* 317 */ _CFFI_OP(_CFFI_OP_POINTER, 318), // LEAP_DEVICE_FAILURE_EVENT const *
/* 318 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 15), // LEAP_DEVICE_FAILURE_EVENT
/* 319 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 16), // LEAP_DEVICE_INFO
/* 320 */ _CFFI_OP(_CFFI_OP_POINTER, 321), // LEAP_DEVICE_STATUS_CHANGE_EVENT const *
/* 321 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 18), // LEAP_DEVICE_STATUS_CHANGE_EVENT
/* 322 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 19), // LEAP_DIGIT
/* 323 */ _CFFI_OP(_CFFI_OP_ARRAY, 322), // LEAP_DIGIT[5]
/* 324 */ (_cffi_opcode_t)(5),
/* 325 */ _CFFI_OP(_CFFI_OP_POINTER, 326), // LEAP_DISTORTION_MATRIX *
/* 326 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 20), // LEAP_DISTORTION_MATRIX
/* 327 */ _CFFI_OP(_CFFI_OP_POINTER, 328), // LEAP_DROPPED_FRAME_EVENT const *
/* 328 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 21), // LEAP_DROPPED_FRAME_EVENT
/* 329 */ _CFFI_OP(_CFFI_OP_POINTER, 330), // LEAP_EYE_EVENT const *
/* 330 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 22), // LEAP_EYE_EVENT
/* 331 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 23), // LEAP_FRAME_HEADER
/* 332 */ _CFFI_OP(_CFFI_OP_POINTER, 333), // LEAP_HAND *
/* 333 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 24), // LEAP_HAND
/* 334 */ _CFFI_OP(_CFFI_OP_POINTER, 335), // LEAP_HEAD_POSE_EVENT const *
/* 335 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 25), // LEAP_HEAD_POSE_EVENT
/* 336 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 26), // LEAP_IMAGE
/* 337 */ _CFFI_OP(_CFFI_OP_ARRAY, 336), // LEAP_IMAGE[2]
/* 338 */ (_cffi_opcode_t)(2),
/* 339 */ _CFFI_OP(_CFFI_OP_POINTER, 340), // LEAP_IMAGE_EVENT const *
/* 340 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 27), // LEAP_IMAGE_EVENT
/* 341 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 28), // LEAP_IMAGE_FRAME_DESCRIPTION
/* 342 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 29), // LEAP_IMAGE_PROPERTIES
/* 343 */ _CFFI_OP(_CFFI_OP_POINTER, 344), // LEAP_IMU_EVENT const *
/* 344 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 30), // LEAP_IMU_EVENT
/* 345 */ _CFFI_OP(_CFFI_OP_POINTER, 347), // LEAP_LOG_EVENT *
/* 346 */ _CFFI_OP(_CFFI_OP_POINTER, 347), // LEAP_LOG_EVENT const *
/* 347 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 31), // LEAP_LOG_EVENT
/* 348 */ _CFFI_OP(_CFFI_OP_POINTER, 349), // LEAP_LOG_EVENTS const *
/* 349 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 32), // LEAP_LOG_EVENTS
/* 350 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 33), // LEAP_MATRIX_3x3
/* 351 */ _CFFI_OP(_CFFI_OP_POINTER, 352), // LEAP_NEW_DEVICE_TRANSFORM const *
/* 352 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 34), // LEAP_NEW_DEVICE_TRANSFORM
/* 353 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 35), // LEAP_PALM
/* 354 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 36), // LEAP_POINT_MAPPING
/* 355 */ _CFFI_OP(_CFFI_OP_POINTER, 356), // LEAP_POINT_MAPPING_CHANGE_EVENT const *
/* 356 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 37), // LEAP_POINT_MAPPING_CHANGE_EVENT
/* 357 */ _CFFI_OP(_CFFI_OP_POINTER, 358), // LEAP_POLICY_EVENT const *
/* 358 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 38), // LEAP_POLICY_EVENT
/* 359 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 39), // LEAP_QUATERNION
/* 360 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 42), // LEAP_RECORDING_STATUS
/* 361 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 43), // LEAP_SERVER_STATUS
/* 362 */ _CFFI_OP(_CFFI_OP_POINTER, 363), // LEAP_SERVER_STATUS_DEVICE const *
/* 363 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 44), // LEAP_SERVER_STATUS_DEVICE
/* 364 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 45), // LEAP_TELEMETRY_DATA
/* 365 */ _CFFI_OP(_CFFI_OP_POINTER, 366), // LEAP_TRACKING_EVENT const *
/* 366 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 46), // LEAP_TRACKING_EVENT
/* 367 */ _CFFI_OP(_CFFI_OP_POINTER, 368), // LEAP_TRACKING_MODE_EVENT const *
/* 368 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 47), // LEAP_TRACKING_MODE_EVENT
/* 369 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 48), // LEAP_VARIANT
/* 370 */ _CFFI_OP(_CFFI_OP_POINTER, 3), // LEAP_VECTOR *
/* 371 */ _CFFI_OP(_CFFI_OP_ARRAY, 3), // LEAP_VECTOR[3]
/* 372 */ (_cffi_opcode_t)(3),
/* 373 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 50), // LEAP_VERSION
/* 374 */ _CFFI_OP(_CFFI_OP_POINTER, 375), // char *
/* 375 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 2), // char
/* 376 */ _CFFI_OP(_CFFI_OP_ENUM, 1), // eLeapCameraCalibrationType
/* 377 */ _CFFI_OP(_CFFI_OP_ENUM, 2), // eLeapConnectionConfig
/* 378 */ _CFFI_OP(_CFFI_OP_ENUM, 3), // eLeapConnectionStatus
/* 379 */ _CFFI_OP(_CFFI_OP_ENUM, 5), // eLeapDeviceStatus
/* 380 */ _CFFI_OP(_CFFI_OP_ENUM, 6), // eLeapDroppedFrameType
/* 381 */ _CFFI_OP(_CFFI_OP_ENUM, 7), // eLeapEventType
/* 382 */ _CFFI_OP(_CFFI_OP_ENUM, 8), // eLeapHandType
/* 383 */ _CFFI_OP(_CFFI_OP_ENUM, 9), // eLeapIMUFlag
/* 384 */ _CFFI_OP(_CFFI_OP_ENUM, 10), // eLeapImageFormat
/* 385 */ _CFFI_OP(_CFFI_OP_ENUM, 11), // eLeapImageType
/* 386 */ _CFFI_OP(_CFFI_OP_ENUM, 12), // eLeapLogSeverity
/* 387 */ _CFFI_OP(_CFFI_OP_ENUM, 14), // eLeapPolicyFlag
/* 388 */ _CFFI_OP(_CFFI_OP_ENUM, 15), // eLeapRS
/* 389 */ _CFFI_OP(_CFFI_OP_ENUM, 16), // eLeapRecordingFlags
/* 390 */ _CFFI_OP(_CFFI_OP_ENUM, 17), // eLeapServiceDisposition
/* 391 */ _CFFI_OP(_CFFI_OP_ENUM, 19), // eLeapTrackingOrigin
/* 392 */ _CFFI_OP(_CFFI_OP_ENUM, 20), // eLeapValueType
/* 393 */ _CFFI_OP(_CFFI_OP_ENUM, 22), // enum eLeapDeviceCaps
/* 394 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 13), // float
/* 395 */ _CFFI_OP(_CFFI_OP_ARRAY, 394), // float[3]
/* 396 */ (_cffi_opcode_t)(3),
/* 397 */ _CFFI_OP(_CFFI_OP_ARRAY, 394), // float[4]
/* 398 */ (_cffi_opcode_t)(4),
/* 399 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 21), // int32_t
/* 400 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 0), // struct $2
/* 401 */ _CFFI_OP(_CFFI_OP_ARRAY, 400), // struct $2[64]
/* 402 */ (_cffi_opcode_t)(64),
/* 403 */ _CFFI_OP(_CFFI_OP_ARRAY, 401), // struct $2[64][64]
/* 404 */ (_cffi_opcode_t)(64),
/* 405 */ _CFFI_OP(_CFFI_OP_POINTER, 406), // struct _LEAP_CALIBRATION *
/* 406 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 3), // struct _LEAP_CALIBRATION
/* 407 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 4), // struct _LEAP_CLOCK_REBASER
/* 408 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 7), // struct _LEAP_CONNECTION
/* 409 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 13), // struct _LEAP_DEVICE
/* 410 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 40), // struct _LEAP_RECORDING
/* 411 */ _CFFI_OP(_CFFI_OP_POINTER, 260), // void *(*)(uint32_t, eLeapAllocatorType, void *)
/* 412 */ _CFFI_OP(_CFFI_OP_POINTER, 414), // void const *
/* 413 */ _CFFI_OP(_CFFI_OP_POINTER, 296), // void(*)(void *, void *)
/* 414 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 0), // void
};

static int _cffi_const_eLeapAllocatorType_Int8(unsigned long long *o)
{
  int n = (eLeapAllocatorType_Int8) <= 0;
  *o = (unsigned long long)((eLeapAllocatorType_Int8) | 0);  /* check that eLeapAllocatorType_Int8 is an integer */
  return n;
}

static int _cffi_const_eLeapAllocatorType_Uint8(unsigned long long *o)
{
  int n = (eLeapAllocatorType_Uint8) <= 0;
  *o = (unsigned long long)((eLeapAllocatorType_Uint8) | 0);  /* check that eLeapAllocatorType_Uint8 is an integer */
  return n;
}

static int _cffi_const_eLeapAllocatorType_Int16(unsigned long long *o)
{
  int n = (eLeapAllocatorType_Int16) <= 0;
  *o = (unsigned long long)((eLeapAllocatorType_Int16) | 0);  /* check that eLeapAllocatorType_Int16 is an integer */
  return n;
}

static int _cffi_const_eLeapAllocatorType_UInt16(unsigned long long *o)
{
  int n = (eLeapAllocatorType_UInt16) <= 0;
  *o = (unsigned long long)((eLeapAllocatorType_UInt16) | 0);  /* check that eLeapAllocatorType_UInt16 is an integer */
  return n;
}

static int _cffi_const_eLeapAllocatorType_Int32(unsigned long long *o)
{
  int n = (eLeapAllocatorType_Int32) <= 0;
  *o = (unsigned long long)((eLeapAllocatorType_Int32) | 0);  /* check that eLeapAllocatorType_Int32 is an integer */
  return n;
}

static int _cffi_const_eLeapAllocatorType_UInt32(unsigned long long *o)
{
  int n = (eLeapAllocatorType_UInt32) <= 0;
  *o = (unsigned long long)((eLeapAllocatorType_UInt32) | 0);  /* check that eLeapAllocatorType_UInt32 is an integer */
  return n;
}

static int _cffi_const_eLeapAllocatorType_Float(unsigned long long *o)
{
  int n = (eLeapAllocatorType_Float) <= 0;
  *o = (unsigned long long)((eLeapAllocatorType_Float) | 0);  /* check that eLeapAllocatorType_Float is an integer */
  return n;
}

static int _cffi_const_eLeapAllocatorType_Int64(unsigned long long *o)
{
  int n = (eLeapAllocatorType_Int64) <= 0;
  *o = (unsigned long long)((eLeapAllocatorType_Int64) | 0);  /* check that eLeapAllocatorType_Int64 is an integer */
  return n;
}

static int _cffi_const_eLeapAllocatorType_UInt64(unsigned long long *o)
{
  int n = (eLeapAllocatorType_UInt64) <= 0;
  *o = (unsigned long long)((eLeapAllocatorType_UInt64) | 0);  /* check that eLeapAllocatorType_UInt64 is an integer */
  return n;
}

static int _cffi_const_eLeapAllocatorType_Double(unsigned long long *o)
{
  int n = (eLeapAllocatorType_Double) <= 0;
  *o = (unsigned long long)((eLeapAllocatorType_Double) | 0);  /* check that eLeapAllocatorType_Double is an integer */
  return n;
}

static int _cffi_const_eLeapCameraCalibrationType_infrared(unsigned long long *o)
{
  int n = (eLeapCameraCalibrationType_infrared) <= 0;
  *o = (unsigned long long)((eLeapCameraCalibrationType_infrared) | 0);  /* check that eLeapCameraCalibrationType_infrared is an integer */
  return n;
}

static int _cffi_const_eLeapCameraCalibrationType_visual(unsigned long long *o)
{
  int n = (eLeapCameraCalibrationType_visual) <= 0;
  *o = (unsigned long long)((eLeapCameraCalibrationType_visual) | 0);  /* check that eLeapCameraCalibrationType_visual is an integer */
  return n;
}

static int _cffi_const_eLeapConnectionConfig_MultiDeviceAware(unsigned long long *o)
{
  int n = (eLeapConnectionConfig_MultiDeviceAware) <= 0;
  *o = (unsigned long long)((eLeapConnectionConfig_MultiDeviceAware) | 0);  /* check that eLeapConnectionConfig_MultiDeviceAware is an integer */
  return n;
}

static int _cffi_const_eLeapConnectionStatus_NotConnected(unsigned long long *o)
{
  int n = (eLeapConnectionStatus_NotConnected) <= 0;
  *o = (unsigned long long)((eLeapConnectionStatus_NotConnected) | 0);  /* check that eLeapConnectionStatus_NotConnected is an integer */
  return n;
}

static int _cffi_const_eLeapConnectionStatus_Connected(unsigned long long *o)
{
  int n = (eLeapConnectionStatus_Connected) <= 0;
  *o = (unsigned long long)((eLeapConnectionStatus_Connected) | 0);  /* check that eLeapConnectionStatus_Connected is an integer */
  return n;
}

static int _cffi_const_eLeapConnectionStatus_HandshakeIncomplete(unsigned long long *o)
{
  int n = (eLeapConnectionStatus_HandshakeIncomplete) <= 0;
  *o = (unsigned long long)((eLeapConnectionStatus_HandshakeIncomplete) | 0);  /* check that eLeapConnectionStatus_HandshakeIncomplete is an integer */
  return n;
}

static int _cffi_const_eLeapConnectionStatus_NotRunning(unsigned long long *o)
{
  int n = (eLeapConnectionStatus_NotRunning) <= 0;
  *o = (unsigned long long)((eLeapConnectionStatus_NotRunning) | 0);  /* check that eLeapConnectionStatus_NotRunning is an integer */
  return n;
}

static int _cffi_const_eLeapDevicePID_Unknown(unsigned long long *o)
{
  int n = (eLeapDevicePID_Unknown) <= 0;
  *o = (unsigned long long)((eLeapDevicePID_Unknown) | 0);  /* check that eLeapDevicePID_Unknown is an integer */
  return n;
}

static int _cffi_const_eLeapDevicePID_Peripheral(unsigned long long *o)
{
  int n = (eLeapDevicePID_Peripheral) <= 0;
  *o = (unsigned long long)((eLeapDevicePID_Peripheral) | 0);  /* check that eLeapDevicePID_Peripheral is an integer */
  return n;
}

static int _cffi_const_eLeapDevicePID_Dragonfly(unsigned long long *o)
{
  int n = (eLeapDevicePID_Dragonfly) <= 0;
  *o = (unsigned long long)((eLeapDevicePID_Dragonfly) | 0);  /* check that eLeapDevicePID_Dragonfly is an integer */
  return n;
}

static int _cffi_const_eLeapDevicePID_Nightcrawler(unsigned long long *o)
{
  int n = (eLeapDevicePID_Nightcrawler) <= 0;
  *o = (unsigned long long)((eLeapDevicePID_Nightcrawler) | 0);  /* check that eLeapDevicePID_Nightcrawler is an integer */
  return n;
}

static int _cffi_const_eLeapDevicePID_Rigel(unsigned long long *o)
{
  int n = (eLeapDevicePID_Rigel) <= 0;
  *o = (unsigned long long)((eLeapDevicePID_Rigel) | 0);  /* check that eLeapDevicePID_Rigel is an integer */
  return n;
}

static int _cffi_const_eLeapDevicePID_SIR170(unsigned long long *o)
{
  int n = (eLeapDevicePID_SIR170) <= 0;
  *o = (unsigned long long)((eLeapDevicePID_SIR170) | 0);  /* check that eLeapDevicePID_SIR170 is an integer */
  return n;
}

static int _cffi_const_eLeapDevicePID_3Di(unsigned long long *o)
{
  int n = (eLeapDevicePID_3Di) <= 0;
  *o = (unsigned long long)((eLeapDevicePID_3Di) | 0);  /* check that eLeapDevicePID_3Di is an integer */
  return n;
}

static int _cffi_const_eLeapDevicePID_LMC2(unsigned long long *o)
{
  int n = (eLeapDevicePID_LMC2) <= 0;
  *o = (unsigned long long)((eLeapDevicePID_LMC2) | 0);  /* check that eLeapDevicePID_LMC2 is an integer */
  return n;
}

static int _cffi_const_eLeapDevicePID_Invalid(unsigned long long *o)
{
  int n = (eLeapDevicePID_Invalid) <= 0;
  *o = (unsigned long long)((eLeapDevicePID_Invalid) | 0);  /* check that eLeapDevicePID_Invalid is an integer */
  return n;
}

static int _cffi_const_eLeapDeviceStatus_Streaming(unsigned long long *o)
{
  int n = (eLeapDeviceStatus_Streaming) <= 0;
  *o = (unsigned long long)((eLeapDeviceStatus_Streaming) | 0);  /* check that eLeapDeviceStatus_Streaming is an integer */
  return n;
}

static int _cffi_const_eLeapDeviceStatus_Paused(unsigned long long *o)
{
  int n = (eLeapDeviceStatus_Paused) <= 0;
  *o = (unsigned long long)((eLeapDeviceStatus_Paused) | 0);  /* check that eLeapDeviceStatus_Paused is an integer */
  return n;
}

static int _cffi_const_eLeapDeviceStatus_Robust(unsigned long long *o)
{
  int n = (eLeapDeviceStatus_Robust) <= 0;
  *o = (unsigned long long)((eLeapDeviceStatus_Robust) | 0);  /* check that eLeapDeviceStatus_Robust is an integer */
  return n;
}

static int _cffi_const_eLeapDeviceStatus_Smudged(unsigned long long *o)
{
  int n = (eLeapDeviceStatus_Smudged) <= 0;
  *o = (unsigned long long)((eLeapDeviceStatus_Smudged) | 0);  /* check that eLeapDeviceStatus_Smudged is an integer */
  return n;
}

static int _cffi_const_eLeapDeviceStatus_LowResource(unsigned long long *o)
{
  int n = (eLeapDeviceStatus_LowResource) <= 0;
  *o = (unsigned long long)((eLeapDeviceStatus_LowResource) | 0);  /* check that eLeapDeviceStatus_LowResource is an integer */
  return n;
}

static int _cffi_const_eLeapDeviceStatus_UnknownFailure(unsigned long long *o)
{
  int n = (eLeapDeviceStatus_UnknownFailure) <= 0;
  *o = (unsigned long long)((eLeapDeviceStatus_UnknownFailure) | 0);  /* check that eLeapDeviceStatus_UnknownFailure is an integer */
  return n;
}

static int _cffi_const_eLeapDeviceStatus_BadCalibration(unsigned long long *o)
{
  int n = (eLeapDeviceStatus_BadCalibration) <= 0;
  *o = (unsigned long long)((eLeapDeviceStatus_BadCalibration) | 0);  /* check that eLeapDeviceStatus_BadCalibration is an integer */
  return n;
}

static int _cffi_const_eLeapDeviceStatus_BadFirmware(unsigned long long *o)
{
  int n = (eLeapDeviceStatus_BadFirmware) <= 0;
  *o = (unsigned long long)((eLeapDeviceStatus_BadFirmware) | 0);  /* check that eLeapDeviceStatus_BadFirmware is an integer */
  return n;
}

static int _cffi_const_eLeapDeviceStatus_BadTransport(unsigned long long *o)
{
  int n = (eLeapDeviceStatus_BadTransport) <= 0;
  *o = (unsigned long long)((eLeapDeviceStatus_BadTransport) | 0);  /* check that eLeapDeviceStatus_BadTransport is an integer */
  return n;
}

static int _cffi_const_eLeapDeviceStatus_BadControl(unsigned long long *o)
{
  int n = (eLeapDeviceStatus_BadControl) <= 0;
  *o = (unsigned long long)((eLeapDeviceStatus_BadControl) | 0);  /* check that eLeapDeviceStatus_BadControl is an integer */
  return n;
}

static int _cffi_const_eLeapDroppedFrameType_PreprocessingQueue(unsigned long long *o)
{
  int n = (eLeapDroppedFrameType_PreprocessingQueue) <= 0;
  *o = (unsigned long long)((eLeapDroppedFrameType_PreprocessingQueue) | 0);  /* check that eLeapDroppedFrameType_PreprocessingQueue is an integer */
  return n;
}

static int _cffi_const_eLeapDroppedFrameType_TrackingQueue(unsigned long long *o)
{
  int n = (eLeapDroppedFrameType_TrackingQueue) <= 0;
  *o = (unsigned long long)((eLeapDroppedFrameType_TrackingQueue) | 0);  /* check that eLeapDroppedFrameType_TrackingQueue is an integer */
  return n;
}

static int _cffi_const_eLeapDroppedFrameType_Other(unsigned long long *o)
{
  int n = (eLeapDroppedFrameType_Other) <= 0;
  *o = (unsigned long long)((eLeapDroppedFrameType_Other) | 0);  /* check that eLeapDroppedFrameType_Other is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_None(unsigned long long *o)
{
  int n = (eLeapEventType_None) <= 0;
  *o = (unsigned long long)((eLeapEventType_None) | 0);  /* check that eLeapEventType_None is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_Connection(unsigned long long *o)
{
  int n = (eLeapEventType_Connection) <= 0;
  *o = (unsigned long long)((eLeapEventType_Connection) | 0);  /* check that eLeapEventType_Connection is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_ConnectionLost(unsigned long long *o)
{
  int n = (eLeapEventType_ConnectionLost) <= 0;
  *o = (unsigned long long)((eLeapEventType_ConnectionLost) | 0);  /* check that eLeapEventType_ConnectionLost is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_Device(unsigned long long *o)
{
  int n = (eLeapEventType_Device) <= 0;
  *o = (unsigned long long)((eLeapEventType_Device) | 0);  /* check that eLeapEventType_Device is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_DeviceFailure(unsigned long long *o)
{
  int n = (eLeapEventType_DeviceFailure) <= 0;
  *o = (unsigned long long)((eLeapEventType_DeviceFailure) | 0);  /* check that eLeapEventType_DeviceFailure is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_Policy(unsigned long long *o)
{
  int n = (eLeapEventType_Policy) <= 0;
  *o = (unsigned long long)((eLeapEventType_Policy) | 0);  /* check that eLeapEventType_Policy is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_Tracking(unsigned long long *o)
{
  int n = (eLeapEventType_Tracking) <= 0;
  *o = (unsigned long long)((eLeapEventType_Tracking) | 0);  /* check that eLeapEventType_Tracking is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_ImageRequestError(unsigned long long *o)
{
  int n = (eLeapEventType_ImageRequestError) <= 0;
  *o = (unsigned long long)((eLeapEventType_ImageRequestError) | 0);  /* check that eLeapEventType_ImageRequestError is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_ImageComplete(unsigned long long *o)
{
  int n = (eLeapEventType_ImageComplete) <= 0;
  *o = (unsigned long long)((eLeapEventType_ImageComplete) | 0);  /* check that eLeapEventType_ImageComplete is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_LogEvent(unsigned long long *o)
{
  int n = (eLeapEventType_LogEvent) <= 0;
  *o = (unsigned long long)((eLeapEventType_LogEvent) | 0);  /* check that eLeapEventType_LogEvent is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_DeviceLost(unsigned long long *o)
{
  int n = (eLeapEventType_DeviceLost) <= 0;
  *o = (unsigned long long)((eLeapEventType_DeviceLost) | 0);  /* check that eLeapEventType_DeviceLost is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_ConfigResponse(unsigned long long *o)
{
  int n = (eLeapEventType_ConfigResponse) <= 0;
  *o = (unsigned long long)((eLeapEventType_ConfigResponse) | 0);  /* check that eLeapEventType_ConfigResponse is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_ConfigChange(unsigned long long *o)
{
  int n = (eLeapEventType_ConfigChange) <= 0;
  *o = (unsigned long long)((eLeapEventType_ConfigChange) | 0);  /* check that eLeapEventType_ConfigChange is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_DeviceStatusChange(unsigned long long *o)
{
  int n = (eLeapEventType_DeviceStatusChange) <= 0;
  *o = (unsigned long long)((eLeapEventType_DeviceStatusChange) | 0);  /* check that eLeapEventType_DeviceStatusChange is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_DroppedFrame(unsigned long long *o)
{
  int n = (eLeapEventType_DroppedFrame) <= 0;
  *o = (unsigned long long)((eLeapEventType_DroppedFrame) | 0);  /* check that eLeapEventType_DroppedFrame is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_Image(unsigned long long *o)
{
  int n = (eLeapEventType_Image) <= 0;
  *o = (unsigned long long)((eLeapEventType_Image) | 0);  /* check that eLeapEventType_Image is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_PointMappingChange(unsigned long long *o)
{
  int n = (eLeapEventType_PointMappingChange) <= 0;
  *o = (unsigned long long)((eLeapEventType_PointMappingChange) | 0);  /* check that eLeapEventType_PointMappingChange is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_TrackingMode(unsigned long long *o)
{
  int n = (eLeapEventType_TrackingMode) <= 0;
  *o = (unsigned long long)((eLeapEventType_TrackingMode) | 0);  /* check that eLeapEventType_TrackingMode is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_LogEvents(unsigned long long *o)
{
  int n = (eLeapEventType_LogEvents) <= 0;
  *o = (unsigned long long)((eLeapEventType_LogEvents) | 0);  /* check that eLeapEventType_LogEvents is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_HeadPose(unsigned long long *o)
{
  int n = (eLeapEventType_HeadPose) <= 0;
  *o = (unsigned long long)((eLeapEventType_HeadPose) | 0);  /* check that eLeapEventType_HeadPose is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_Eyes(unsigned long long *o)
{
  int n = (eLeapEventType_Eyes) <= 0;
  *o = (unsigned long long)((eLeapEventType_Eyes) | 0);  /* check that eLeapEventType_Eyes is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_IMU(unsigned long long *o)
{
  int n = (eLeapEventType_IMU) <= 0;
  *o = (unsigned long long)((eLeapEventType_IMU) | 0);  /* check that eLeapEventType_IMU is an integer */
  return n;
}

static int _cffi_const_eLeapEventType_NewDeviceTransform(unsigned long long *o)
{
  int n = (eLeapEventType_NewDeviceTransform) <= 0;
  *o = (unsigned long long)((eLeapEventType_NewDeviceTransform) | 0);  /* check that eLeapEventType_NewDeviceTransform is an integer */
  return n;
}

static int _cffi_const_eLeapHandType_Left(unsigned long long *o)
{
  int n = (eLeapHandType_Left) <= 0;
  *o = (unsigned long long)((eLeapHandType_Left) | 0);  /* check that eLeapHandType_Left is an integer */
  return n;
}

static int _cffi_const_eLeapHandType_Right(unsigned long long *o)
{
  int n = (eLeapHandType_Right) <= 0;
  *o = (unsigned long long)((eLeapHandType_Right) | 0);  /* check that eLeapHandType_Right is an integer */
  return n;
}

static int _cffi_const_eLeapIMUFlag_HasAccelerometer(unsigned long long *o)
{
  int n = (eLeapIMUFlag_HasAccelerometer) <= 0;
  *o = (unsigned long long)((eLeapIMUFlag_HasAccelerometer) | 0);  /* check that eLeapIMUFlag_HasAccelerometer is an integer */
  return n;
}

static int _cffi_const_eLeapIMUFlag_HasGyroscope(unsigned long long *o)
{
  int n = (eLeapIMUFlag_HasGyroscope) <= 0;
  *o = (unsigned long long)((eLeapIMUFlag_HasGyroscope) | 0);  /* check that eLeapIMUFlag_HasGyroscope is an integer */
  return n;
}

static int _cffi_const_eLeapIMUFlag_HasTemperature(unsigned long long *o)
{
  int n = (eLeapIMUFlag_HasTemperature) <= 0;
  *o = (unsigned long long)((eLeapIMUFlag_HasTemperature) | 0);  /* check that eLeapIMUFlag_HasTemperature is an integer */
  return n;
}

static int _cffi_const_eLeapImageFormat_UNKNOWN(unsigned long long *o)
{
  int n = (eLeapImageFormat_UNKNOWN) <= 0;
  *o = (unsigned long long)((eLeapImageFormat_UNKNOWN) | 0);  /* check that eLeapImageFormat_UNKNOWN is an integer */
  return n;
}

static int _cffi_const_eLeapImageFormat_IR(unsigned long long *o)
{
  int n = (eLeapImageFormat_IR) <= 0;
  *o = (unsigned long long)((eLeapImageFormat_IR) | 0);  /* check that eLeapImageFormat_IR is an integer */
  return n;
}

static int _cffi_const_eLeapImageFormat_RGBIr_Bayer(unsigned long long *o)
{
  int n = (eLeapImageFormat_RGBIr_Bayer) <= 0;
  *o = (unsigned long long)((eLeapImageFormat_RGBIr_Bayer) | 0);  /* check that eLeapImageFormat_RGBIr_Bayer is an integer */
  return n;
}

static int _cffi_const_eLeapImageType_UNKNOWN(unsigned long long *o)
{
  int n = (eLeapImageType_UNKNOWN) <= 0;
  *o = (unsigned long long)((eLeapImageType_UNKNOWN) | 0);  /* check that eLeapImageType_UNKNOWN is an integer */
  return n;
}

static int _cffi_const_eLeapImageType_Default(unsigned long long *o)
{
  int n = (eLeapImageType_Default) <= 0;
  *o = (unsigned long long)((eLeapImageType_Default) | 0);  /* check that eLeapImageType_Default is an integer */
  return n;
}

static int _cffi_const_eLeapImageType_Raw(unsigned long long *o)
{
  int n = (eLeapImageType_Raw) <= 0;
  *o = (unsigned long long)((eLeapImageType_Raw) | 0);  /* check that eLeapImageType_Raw is an integer */
  return n;
}

static int _cffi_const_eLeapLogSeverity_Unknown(unsigned long long *o)
{
  int n = (eLeapLogSeverity_Unknown) <= 0;
  *o = (unsigned long long)((eLeapLogSeverity_Unknown) | 0);  /* check that eLeapLogSeverity_Unknown is an integer */
  return n;
}

static int _cffi_const_eLeapLogSeverity_Critical(unsigned long long *o)
{
  int n = (eLeapLogSeverity_Critical) <= 0;
  *o = (unsigned long long)((eLeapLogSeverity_Critical) | 0);  /* check that eLeapLogSeverity_Critical is an integer */
  return n;
}

static int _cffi_const_eLeapLogSeverity_Warning(unsigned long long *o)
{
  int n = (eLeapLogSeverity_Warning) <= 0;
  *o = (unsigned long long)((eLeapLogSeverity_Warning) | 0);  /* check that eLeapLogSeverity_Warning is an integer */
  return n;
}

static int _cffi_const_eLeapLogSeverity_Information(unsigned long long *o)
{
  int n = (eLeapLogSeverity_Information) <= 0;
  *o = (unsigned long long)((eLeapLogSeverity_Information) | 0);  /* check that eLeapLogSeverity_Information is an integer */
  return n;
}

static int _cffi_const_eLeapPerspectiveType_invalid(unsigned long long *o)
{
  int n = (eLeapPerspectiveType_invalid) <= 0;
  *o = (unsigned long long)((eLeapPerspectiveType_invalid) | 0);  /* check that eLeapPerspectiveType_invalid is an integer */
  return n;
}

static int _cffi_const_eLeapPerspectiveType_stereo_left(unsigned long long *o)
{
  int n = (eLeapPerspectiveType_stereo_left) <= 0;
  *o = (unsigned long long)((eLeapPerspectiveType_stereo_left) | 0);  /* check that eLeapPerspectiveType_stereo_left is an integer */
  return n;
}

static int _cffi_const_eLeapPerspectiveType_stereo_right(unsigned long long *o)
{
  int n = (eLeapPerspectiveType_stereo_right) <= 0;
  *o = (unsigned long long)((eLeapPerspectiveType_stereo_right) | 0);  /* check that eLeapPerspectiveType_stereo_right is an integer */
  return n;
}

static int _cffi_const_eLeapPerspectiveType_mono(unsigned long long *o)
{
  int n = (eLeapPerspectiveType_mono) <= 0;
  *o = (unsigned long long)((eLeapPerspectiveType_mono) | 0);  /* check that eLeapPerspectiveType_mono is an integer */
  return n;
}

static int _cffi_const_eLeapPolicyFlag_BackgroundFrames(unsigned long long *o)
{
  int n = (eLeapPolicyFlag_BackgroundFrames) <= 0;
  *o = (unsigned long long)((eLeapPolicyFlag_BackgroundFrames) | 0);  /* check that eLeapPolicyFlag_BackgroundFrames is an integer */
  return n;
}

static int _cffi_const_eLeapPolicyFlag_Images(unsigned long long *o)
{
  int n = (eLeapPolicyFlag_Images) <= 0;
  *o = (unsigned long long)((eLeapPolicyFlag_Images) | 0);  /* check that eLeapPolicyFlag_Images is an integer */
  return n;
}

static int _cffi_const_eLeapPolicyFlag_OptimizeHMD(unsigned long long *o)
{
  int n = (eLeapPolicyFlag_OptimizeHMD) <= 0;
  *o = (unsigned long long)((eLeapPolicyFlag_OptimizeHMD) | 0);  /* check that eLeapPolicyFlag_OptimizeHMD is an integer */
  return n;
}

static int _cffi_const_eLeapPolicyFlag_AllowPauseResume(unsigned long long *o)
{
  int n = (eLeapPolicyFlag_AllowPauseResume) <= 0;
  *o = (unsigned long long)((eLeapPolicyFlag_AllowPauseResume) | 0);  /* check that eLeapPolicyFlag_AllowPauseResume is an integer */
  return n;
}

static int _cffi_const_eLeapPolicyFlag_MapPoints(unsigned long long *o)
{
  int n = (eLeapPolicyFlag_MapPoints) <= 0;
  *o = (unsigned long long)((eLeapPolicyFlag_MapPoints) | 0);  /* check that eLeapPolicyFlag_MapPoints is an integer */
  return n;
}

static int _cffi_const_eLeapPolicyFlag_OptimizeScreenTop(unsigned long long *o)
{
  int n = (eLeapPolicyFlag_OptimizeScreenTop) <= 0;
  *o = (unsigned long long)((eLeapPolicyFlag_OptimizeScreenTop) | 0);  /* check that eLeapPolicyFlag_OptimizeScreenTop is an integer */
  return n;
}

static int _cffi_const_eLeapRS_Success(unsigned long long *o)
{
  int n = (eLeapRS_Success) <= 0;
  *o = (unsigned long long)((eLeapRS_Success) | 0);  /* check that eLeapRS_Success is an integer */
  return n;
}

static int _cffi_const_eLeapRS_UnknownError(unsigned long long *o)
{
  int n = (eLeapRS_UnknownError) <= 0;
  *o = (unsigned long long)((eLeapRS_UnknownError) | 0);  /* check that eLeapRS_UnknownError is an integer */
  return n;
}

static int _cffi_const_eLeapRS_InvalidArgument(unsigned long long *o)
{
  int n = (eLeapRS_InvalidArgument) <= 0;
  *o = (unsigned long long)((eLeapRS_InvalidArgument) | 0);  /* check that eLeapRS_InvalidArgument is an integer */
  return n;
}

static int _cffi_const_eLeapRS_InsufficientResources(unsigned long long *o)
{
  int n = (eLeapRS_InsufficientResources) <= 0;
  *o = (unsigned long long)((eLeapRS_InsufficientResources) | 0);  /* check that eLeapRS_InsufficientResources is an integer */
  return n;
}

static int _cffi_const_eLeapRS_InsufficientBuffer(unsigned long long *o)
{
  int n = (eLeapRS_InsufficientBuffer) <= 0;
  *o = (unsigned long long)((eLeapRS_InsufficientBuffer) | 0);  /* check that eLeapRS_InsufficientBuffer is an integer */
  return n;
}

static int _cffi_const_eLeapRS_Timeout(unsigned long long *o)
{
  int n = (eLeapRS_Timeout) <= 0;
  *o = (unsigned long long)((eLeapRS_Timeout) | 0);  /* check that eLeapRS_Timeout is an integer */
  return n;
}

static int _cffi_const_eLeapRS_NotConnected(unsigned long long *o)
{
  int n = (eLeapRS_NotConnected) <= 0;
  *o = (unsigned long long)((eLeapRS_NotConnected) | 0);  /* check that eLeapRS_NotConnected is an integer */
  return n;
}

static int _cffi_const_eLeapRS_HandshakeIncomplete(unsigned long long *o)
{
  int n = (eLeapRS_HandshakeIncomplete) <= 0;
  *o = (unsigned long long)((eLeapRS_HandshakeIncomplete) | 0);  /* check that eLeapRS_HandshakeIncomplete is an integer */
  return n;
}

static int _cffi_const_eLeapRS_BufferSizeOverflow(unsigned long long *o)
{
  int n = (eLeapRS_BufferSizeOverflow) <= 0;
  *o = (unsigned long long)((eLeapRS_BufferSizeOverflow) | 0);  /* check that eLeapRS_BufferSizeOverflow is an integer */
  return n;
}

static int _cffi_const_eLeapRS_ProtocolError(unsigned long long *o)
{
  int n = (eLeapRS_ProtocolError) <= 0;
  *o = (unsigned long long)((eLeapRS_ProtocolError) | 0);  /* check that eLeapRS_ProtocolError is an integer */
  return n;
}

static int _cffi_const_eLeapRS_InvalidClientID(unsigned long long *o)
{
  int n = (eLeapRS_InvalidClientID) <= 0;
  *o = (unsigned long long)((eLeapRS_InvalidClientID) | 0);  /* check that eLeapRS_InvalidClientID is an integer */
  return n;
}

static int _cffi_const_eLeapRS_UnexpectedClosed(unsigned long long *o)
{
  int n = (eLeapRS_UnexpectedClosed) <= 0;
  *o = (unsigned long long)((eLeapRS_UnexpectedClosed) | 0);  /* check that eLeapRS_UnexpectedClosed is an integer */
  return n;
}

static int _cffi_const_eLeapRS_UnknownImageFrameRequest(unsigned long long *o)
{
  int n = (eLeapRS_UnknownImageFrameRequest) <= 0;
  *o = (unsigned long long)((eLeapRS_UnknownImageFrameRequest) | 0);  /* check that eLeapRS_UnknownImageFrameRequest is an integer */
  return n;
}

static int _cffi_const_eLeapRS_UnknownTrackingFrameID(unsigned long long *o)
{
  int n = (eLeapRS_UnknownTrackingFrameID) <= 0;
  *o = (unsigned long long)((eLeapRS_UnknownTrackingFrameID) | 0);  /* check that eLeapRS_UnknownTrackingFrameID is an integer */
  return n;
}

static int _cffi_const_eLeapRS_RoutineIsNotSeer(unsigned long long *o)
{
  int n = (eLeapRS_RoutineIsNotSeer) <= 0;
  *o = (unsigned long long)((eLeapRS_RoutineIsNotSeer) | 0);  /* check that eLeapRS_RoutineIsNotSeer is an integer */
  return n;
}

static int _cffi_const_eLeapRS_TimestampTooEarly(unsigned long long *o)
{
  int n = (eLeapRS_TimestampTooEarly) <= 0;
  *o = (unsigned long long)((eLeapRS_TimestampTooEarly) | 0);  /* check that eLeapRS_TimestampTooEarly is an integer */
  return n;
}

static int _cffi_const_eLeapRS_ConcurrentPoll(unsigned long long *o)
{
  int n = (eLeapRS_ConcurrentPoll) <= 0;
  *o = (unsigned long long)((eLeapRS_ConcurrentPoll) | 0);  /* check that eLeapRS_ConcurrentPoll is an integer */
  return n;
}

static int _cffi_const_eLeapRS_NotAvailable(unsigned long long *o)
{
  int n = (eLeapRS_NotAvailable) <= 0;
  *o = (unsigned long long)((eLeapRS_NotAvailable) | 0);  /* check that eLeapRS_NotAvailable is an integer */
  return n;
}

static int _cffi_const_eLeapRS_NotStreaming(unsigned long long *o)
{
  int n = (eLeapRS_NotStreaming) <= 0;
  *o = (unsigned long long)((eLeapRS_NotStreaming) | 0);  /* check that eLeapRS_NotStreaming is an integer */
  return n;
}

static int _cffi_const_eLeapRS_CannotOpenDevice(unsigned long long *o)
{
  int n = (eLeapRS_CannotOpenDevice) <= 0;
  *o = (unsigned long long)((eLeapRS_CannotOpenDevice) | 0);  /* check that eLeapRS_CannotOpenDevice is an integer */
  return n;
}

static int _cffi_const_eLeapRS_Unsupported(unsigned long long *o)
{
  int n = (eLeapRS_Unsupported) <= 0;
  *o = (unsigned long long)((eLeapRS_Unsupported) | 0);  /* check that eLeapRS_Unsupported is an integer */
  return n;
}

static int _cffi_const_eLeapRecordingFlags_Error(unsigned long long *o)
{
  int n = (eLeapRecordingFlags_Error) <= 0;
  *o = (unsigned long long)((eLeapRecordingFlags_Error) | 0);  /* check that eLeapRecordingFlags_Error is an integer */
  return n;
}

static int _cffi_const_eLeapRecordingFlags_Reading(unsigned long long *o)
{
  int n = (eLeapRecordingFlags_Reading) <= 0;
  *o = (unsigned long long)((eLeapRecordingFlags_Reading) | 0);  /* check that eLeapRecordingFlags_Reading is an integer */
  return n;
}

static int _cffi_const_eLeapRecordingFlags_Writing(unsigned long long *o)
{
  int n = (eLeapRecordingFlags_Writing) <= 0;
  *o = (unsigned long long)((eLeapRecordingFlags_Writing) | 0);  /* check that eLeapRecordingFlags_Writing is an integer */
  return n;
}

static int _cffi_const_eLeapRecordingFlags_Flushing(unsigned long long *o)
{
  int n = (eLeapRecordingFlags_Flushing) <= 0;
  *o = (unsigned long long)((eLeapRecordingFlags_Flushing) | 0);  /* check that eLeapRecordingFlags_Flushing is an integer */
  return n;
}

static int _cffi_const_eLeapRecordingFlags_Compressed(unsigned long long *o)
{
  int n = (eLeapRecordingFlags_Compressed) <= 0;
  *o = (unsigned long long)((eLeapRecordingFlags_Compressed) | 0);  /* check that eLeapRecordingFlags_Compressed is an integer */
  return n;
}

static int _cffi_const_eLeapServiceState_LowFpsDetected(unsigned long long *o)
{
  int n = (eLeapServiceState_LowFpsDetected) <= 0;
  *o = (unsigned long long)((eLeapServiceState_LowFpsDetected) | 0);  /* check that eLeapServiceState_LowFpsDetected is an integer */
  return n;
}

static int _cffi_const_eLeapServiceState_PoorPerformancePause(unsigned long long *o)
{
  int n = (eLeapServiceState_PoorPerformancePause) <= 0;
  *o = (unsigned long long)((eLeapServiceState_PoorPerformancePause) | 0);  /* check that eLeapServiceState_PoorPerformancePause is an integer */
  return n;
}

static int _cffi_const_eLeapServiceState_TrackingErrorUnknown(unsigned long long *o)
{
  int n = (eLeapServiceState_TrackingErrorUnknown) <= 0;
  *o = (unsigned long long)((eLeapServiceState_TrackingErrorUnknown) | 0);  /* check that eLeapServiceState_TrackingErrorUnknown is an integer */
  return n;
}

static int _cffi_const_eLeapServiceState_ALL(unsigned long long *o)
{
  int n = (eLeapServiceState_ALL) <= 0;
  *o = (unsigned long long)((eLeapServiceState_ALL) | 0);  /* check that eLeapServiceState_ALL is an integer */
  return n;
}

static int _cffi_const_eLeapTrackingMode_Desktop(unsigned long long *o)
{
  int n = (eLeapTrackingMode_Desktop) <= 0;
  *o = (unsigned long long)((eLeapTrackingMode_Desktop) | 0);  /* check that eLeapTrackingMode_Desktop is an integer */
  return n;
}

static int _cffi_const_eLeapTrackingMode_HMD(unsigned long long *o)
{
  int n = (eLeapTrackingMode_HMD) <= 0;
  *o = (unsigned long long)((eLeapTrackingMode_HMD) | 0);  /* check that eLeapTrackingMode_HMD is an integer */
  return n;
}

static int _cffi_const_eLeapTrackingMode_ScreenTop(unsigned long long *o)
{
  int n = (eLeapTrackingMode_ScreenTop) <= 0;
  *o = (unsigned long long)((eLeapTrackingMode_ScreenTop) | 0);  /* check that eLeapTrackingMode_ScreenTop is an integer */
  return n;
}

static int _cffi_const_eLeapTrackingMode_Unknown(unsigned long long *o)
{
  int n = (eLeapTrackingMode_Unknown) <= 0;
  *o = (unsigned long long)((eLeapTrackingMode_Unknown) | 0);  /* check that eLeapTrackingMode_Unknown is an integer */
  return n;
}

static int _cffi_const_eLeapTrackingOrigin_DeviceCenter(unsigned long long *o)
{
  int n = (eLeapTrackingOrigin_DeviceCenter) <= 0;
  *o = (unsigned long long)((eLeapTrackingOrigin_DeviceCenter) | 0);  /* check that eLeapTrackingOrigin_DeviceCenter is an integer */
  return n;
}

static int _cffi_const_eLeapTrackingOrigin_DevicePrimaryCamera(unsigned long long *o)
{
  int n = (eLeapTrackingOrigin_DevicePrimaryCamera) <= 0;
  *o = (unsigned long long)((eLeapTrackingOrigin_DevicePrimaryCamera) | 0);  /* check that eLeapTrackingOrigin_DevicePrimaryCamera is an integer */
  return n;
}

static int _cffi_const_eLeapValueType_Unknown(unsigned long long *o)
{
  int n = (eLeapValueType_Unknown) <= 0;
  *o = (unsigned long long)((eLeapValueType_Unknown) | 0);  /* check that eLeapValueType_Unknown is an integer */
  return n;
}

static int _cffi_const_eLeapValueType_Boolean(unsigned long long *o)
{
  int n = (eLeapValueType_Boolean) <= 0;
  *o = (unsigned long long)((eLeapValueType_Boolean) | 0);  /* check that eLeapValueType_Boolean is an integer */
  return n;
}

static int _cffi_const_eLeapValueType_Int32(unsigned long long *o)
{
  int n = (eLeapValueType_Int32) <= 0;
  *o = (unsigned long long)((eLeapValueType_Int32) | 0);  /* check that eLeapValueType_Int32 is an integer */
  return n;
}

static int _cffi_const_eLeapValueType_Float(unsigned long long *o)
{
  int n = (eLeapValueType_Float) <= 0;
  *o = (unsigned long long)((eLeapValueType_Float) | 0);  /* check that eLeapValueType_Float is an integer */
  return n;
}

static int _cffi_const_eLeapValueType_String(unsigned long long *o)
{
  int n = (eLeapValueType_String) <= 0;
  *o = (unsigned long long)((eLeapValueType_String) | 0);  /* check that eLeapValueType_String is an integer */
  return n;
}

static int _cffi_const_FORCE_DWORD(unsigned long long *o)
{
  int n = (FORCE_DWORD) <= 0;
  *o = (unsigned long long)((FORCE_DWORD) | 0);  /* check that FORCE_DWORD is an integer */
  return n;
}

static int _cffi_const_eLeapVersionPart_ClientLibrary(unsigned long long *o)
{
  int n = (eLeapVersionPart_ClientLibrary) <= 0;
  *o = (unsigned long long)((eLeapVersionPart_ClientLibrary) | 0);  /* check that eLeapVersionPart_ClientLibrary is an integer */
  return n;
}

static int _cffi_const_eLeapVersionPart_ClientProtocol(unsigned long long *o)
{
  int n = (eLeapVersionPart_ClientProtocol) <= 0;
  *o = (unsigned long long)((eLeapVersionPart_ClientProtocol) | 0);  /* check that eLeapVersionPart_ClientProtocol is an integer */
  return n;
}

static int _cffi_const_eLeapVersionPart_ServerLibrary(unsigned long long *o)
{
  int n = (eLeapVersionPart_ServerLibrary) <= 0;
  *o = (unsigned long long)((eLeapVersionPart_ServerLibrary) | 0);  /* check that eLeapVersionPart_ServerLibrary is an integer */
  return n;
}

static int _cffi_const_eLeapVersionPart_ServerProtocol(unsigned long long *o)
{
  int n = (eLeapVersionPart_ServerProtocol) <= 0;
  *o = (unsigned long long)((eLeapVersionPart_ServerProtocol) | 0);  /* check that eLeapVersionPart_ServerProtocol is an integer */
  return n;
}

static int _cffi_const_eLeapDeviceCaps_Color(unsigned long long *o)
{
  int n = (eLeapDeviceCaps_Color) <= 0;
  *o = (unsigned long long)((eLeapDeviceCaps_Color) | 0);  /* check that eLeapDeviceCaps_Color is an integer */
  return n;
}

static void _cffi_d_LeapCameraMatrix(struct _LEAP_CONNECTION * x0, eLeapPerspectiveType x1, float * x2)
{
  LeapCameraMatrix(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapCameraMatrix(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  eLeapPerspectiveType x1;
  float * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapCameraMatrix", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x1, _cffi_type(2), arg1) < 0)
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapCameraMatrix(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapCameraMatrix _cffi_d_LeapCameraMatrix
#endif

static void _cffi_d_LeapCameraMatrixByIndex(struct _LEAP_CONNECTION * x0, uint8_t x1, float * x2)
{
  LeapCameraMatrixByIndex(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapCameraMatrixByIndex(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  uint8_t x1;
  float * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapCameraMatrixByIndex", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint8_t);
  if (x1 == (uint8_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapCameraMatrixByIndex(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapCameraMatrixByIndex _cffi_d_LeapCameraMatrixByIndex
#endif

static void _cffi_d_LeapCameraMatrixByIndexEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, uint8_t x2, float * x3)
{
  LeapCameraMatrixByIndexEx(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapCameraMatrixByIndexEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  uint8_t x2;
  float * x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "LeapCameraMatrixByIndexEx", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, uint8_t);
  if (x2 == (uint8_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg3, (char **)&x3);
  if (datasize != 0) {
    x3 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg3, (char **)&x3,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapCameraMatrixByIndexEx(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapCameraMatrixByIndexEx _cffi_d_LeapCameraMatrixByIndexEx
#endif

static void _cffi_d_LeapCameraMatrixEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, eLeapPerspectiveType x2, float * x3)
{
  LeapCameraMatrixEx(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapCameraMatrixEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  eLeapPerspectiveType x2;
  float * x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "LeapCameraMatrixEx", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x2, _cffi_type(2), arg2) < 0)
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg3, (char **)&x3);
  if (datasize != 0) {
    x3 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg3, (char **)&x3,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapCameraMatrixEx(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapCameraMatrixEx _cffi_d_LeapCameraMatrixEx
#endif

static eLeapRS _cffi_d_LeapCheckLicenseFlag(struct _LEAP_CONNECTION * x0, char const * x1, _Bool * x2)
{
  return LeapCheckLicenseFlag(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapCheckLicenseFlag(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  char const * x1;
  _Bool * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapCheckLicenseFlag", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(83), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (char const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(83), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(90), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (_Bool *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(90), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapCheckLicenseFlag(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapCheckLicenseFlag _cffi_d_LeapCheckLicenseFlag
#endif

static void _cffi_d_LeapCloseConnection(struct _LEAP_CONNECTION * x0)
{
  LeapCloseConnection(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapCloseConnection(PyObject *self, PyObject *arg0)
{
  struct _LEAP_CONNECTION * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapCloseConnection(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapCloseConnection _cffi_d_LeapCloseConnection
#endif

static void _cffi_d_LeapCloseDevice(struct _LEAP_DEVICE * x0)
{
  LeapCloseDevice(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapCloseDevice(PyObject *self, PyObject *arg0)
{
  struct _LEAP_DEVICE * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapCloseDevice(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapCloseDevice _cffi_d_LeapCloseDevice
#endif

static eLeapRS _cffi_d_LeapCreateClockRebaser(struct _LEAP_CLOCK_REBASER * * x0)
{
  return LeapCreateClockRebaser(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapCreateClockRebaser(PyObject *self, PyObject *arg0)
{
  struct _LEAP_CLOCK_REBASER * * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CLOCK_REBASER * *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(40), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapCreateClockRebaser(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapCreateClockRebaser _cffi_d_LeapCreateClockRebaser
#endif

static eLeapRS _cffi_d_LeapCreateConnection(LEAP_CONNECTION_CONFIG const * x0, struct _LEAP_CONNECTION * * x1)
{
  return LeapCreateConnection(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapCreateConnection(PyObject *self, PyObject *args)
{
  LEAP_CONNECTION_CONFIG const * x0;
  struct _LEAP_CONNECTION * * x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LeapCreateConnection", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(29), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (LEAP_CONNECTION_CONFIG const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(29), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION * *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapCreateConnection(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapCreateConnection _cffi_d_LeapCreateConnection
#endif

static void _cffi_d_LeapDestroyClockRebaser(struct _LEAP_CLOCK_REBASER * x0)
{
  LeapDestroyClockRebaser(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapDestroyClockRebaser(PyObject *self, PyObject *arg0)
{
  struct _LEAP_CLOCK_REBASER * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(43), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CLOCK_REBASER *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(43), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapDestroyClockRebaser(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapDestroyClockRebaser _cffi_d_LeapDestroyClockRebaser
#endif

static void _cffi_d_LeapDestroyConnection(struct _LEAP_CONNECTION * x0)
{
  LeapDestroyConnection(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapDestroyConnection(PyObject *self, PyObject *arg0)
{
  struct _LEAP_CONNECTION * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapDestroyConnection(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapDestroyConnection _cffi_d_LeapDestroyConnection
#endif

static char const * _cffi_d_LeapDevicePIDToString(eLeapDevicePID x0)
{
  return LeapDevicePIDToString(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapDevicePIDToString(PyObject *self, PyObject *arg0)
{
  eLeapDevicePID x0;
  char const * result;
  PyObject *pyresult;

  if (_cffi_to_c((char *)&x0, _cffi_type(26), arg0) < 0)
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapDevicePIDToString(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(83));
  return pyresult;
}
#else
#  define _cffi_f_LeapDevicePIDToString _cffi_d_LeapDevicePIDToString
#endif

static _Bool _cffi_d_LeapDeviceTransformAvailable(struct _LEAP_DEVICE * x0)
{
  return LeapDeviceTransformAvailable(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapDeviceTransformAvailable(PyObject *self, PyObject *arg0)
{
  struct _LEAP_DEVICE * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  _Bool result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapDeviceTransformAvailable(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c__Bool(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapDeviceTransformAvailable _cffi_d_LeapDeviceTransformAvailable
#endif

static void _cffi_d_LeapDistortionCoeffs(struct _LEAP_CONNECTION * x0, eLeapPerspectiveType x1, float * x2)
{
  LeapDistortionCoeffs(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapDistortionCoeffs(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  eLeapPerspectiveType x1;
  float * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapDistortionCoeffs", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x1, _cffi_type(2), arg1) < 0)
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapDistortionCoeffs(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapDistortionCoeffs _cffi_d_LeapDistortionCoeffs
#endif

static void _cffi_d_LeapDistortionCoeffsByIndex(struct _LEAP_CONNECTION * x0, uint8_t x1, float * x2)
{
  LeapDistortionCoeffsByIndex(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapDistortionCoeffsByIndex(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  uint8_t x1;
  float * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapDistortionCoeffsByIndex", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint8_t);
  if (x1 == (uint8_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapDistortionCoeffsByIndex(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapDistortionCoeffsByIndex _cffi_d_LeapDistortionCoeffsByIndex
#endif

static void _cffi_d_LeapDistortionCoeffsByIndexEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, uint8_t x2, float * x3)
{
  LeapDistortionCoeffsByIndexEx(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapDistortionCoeffsByIndexEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  uint8_t x2;
  float * x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "LeapDistortionCoeffsByIndexEx", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, uint8_t);
  if (x2 == (uint8_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg3, (char **)&x3);
  if (datasize != 0) {
    x3 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg3, (char **)&x3,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapDistortionCoeffsByIndexEx(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapDistortionCoeffsByIndexEx _cffi_d_LeapDistortionCoeffsByIndexEx
#endif

static void _cffi_d_LeapDistortionCoeffsEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, eLeapPerspectiveType x2, float * x3)
{
  LeapDistortionCoeffsEx(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapDistortionCoeffsEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  eLeapPerspectiveType x2;
  float * x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "LeapDistortionCoeffsEx", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x2, _cffi_type(2), arg2) < 0)
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg3, (char **)&x3);
  if (datasize != 0) {
    x3 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg3, (char **)&x3,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapDistortionCoeffsEx(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapDistortionCoeffsEx _cffi_d_LeapDistortionCoeffsEx
#endif

static void _cffi_d_LeapExtrinsicCameraMatrix(struct _LEAP_CONNECTION * x0, eLeapPerspectiveType x1, float * x2)
{
  LeapExtrinsicCameraMatrix(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapExtrinsicCameraMatrix(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  eLeapPerspectiveType x1;
  float * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapExtrinsicCameraMatrix", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x1, _cffi_type(2), arg1) < 0)
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapExtrinsicCameraMatrix(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapExtrinsicCameraMatrix _cffi_d_LeapExtrinsicCameraMatrix
#endif

static void _cffi_d_LeapExtrinsicCameraMatrixByIndex(struct _LEAP_CONNECTION * x0, uint8_t x1, float * x2)
{
  LeapExtrinsicCameraMatrixByIndex(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapExtrinsicCameraMatrixByIndex(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  uint8_t x1;
  float * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapExtrinsicCameraMatrixByIndex", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint8_t);
  if (x1 == (uint8_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapExtrinsicCameraMatrixByIndex(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapExtrinsicCameraMatrixByIndex _cffi_d_LeapExtrinsicCameraMatrixByIndex
#endif

static void _cffi_d_LeapExtrinsicCameraMatrixByIndexEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, uint8_t x2, float * x3)
{
  LeapExtrinsicCameraMatrixByIndexEx(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapExtrinsicCameraMatrixByIndexEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  uint8_t x2;
  float * x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "LeapExtrinsicCameraMatrixByIndexEx", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, uint8_t);
  if (x2 == (uint8_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg3, (char **)&x3);
  if (datasize != 0) {
    x3 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg3, (char **)&x3,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapExtrinsicCameraMatrixByIndexEx(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapExtrinsicCameraMatrixByIndexEx _cffi_d_LeapExtrinsicCameraMatrixByIndexEx
#endif

static void _cffi_d_LeapExtrinsicCameraMatrixEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, eLeapPerspectiveType x2, float * x3)
{
  LeapExtrinsicCameraMatrixEx(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapExtrinsicCameraMatrixEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  eLeapPerspectiveType x2;
  float * x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "LeapExtrinsicCameraMatrixEx", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x2, _cffi_type(2), arg2) < 0)
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg3, (char **)&x3);
  if (datasize != 0) {
    x3 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg3, (char **)&x3,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapExtrinsicCameraMatrixEx(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapExtrinsicCameraMatrixEx _cffi_d_LeapExtrinsicCameraMatrixEx
#endif

static eLeapRS _cffi_d_LeapGetConnectionInfo(struct _LEAP_CONNECTION * x0, LEAP_CONNECTION_INFO * x1)
{
  return LeapGetConnectionInfo(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapGetConnectionInfo(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  LEAP_CONNECTION_INFO * x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LeapGetConnectionInfo", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(61), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (LEAP_CONNECTION_INFO *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(61), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapGetConnectionInfo(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapGetConnectionInfo _cffi_d_LeapGetConnectionInfo
#endif

static eLeapRS _cffi_d_LeapGetDeviceCameraCount(struct _LEAP_DEVICE * x0, uint8_t * x1)
{
  return LeapGetDeviceCameraCount(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapGetDeviceCameraCount(PyObject *self, PyObject *args)
{
  struct _LEAP_DEVICE * x0;
  uint8_t * x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LeapGetDeviceCameraCount", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(224), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (uint8_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(224), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapGetDeviceCameraCount(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapGetDeviceCameraCount _cffi_d_LeapGetDeviceCameraCount
#endif

static eLeapRS _cffi_d_LeapGetDeviceFrameRate(struct _LEAP_CONNECTION * x0, float * x1)
{
  return LeapGetDeviceFrameRate(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapGetDeviceFrameRate(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  float * x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LeapGetDeviceFrameRate", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapGetDeviceFrameRate(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapGetDeviceFrameRate _cffi_d_LeapGetDeviceFrameRate
#endif

static eLeapRS _cffi_d_LeapGetDeviceFrameRateEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, float * x2)
{
  return LeapGetDeviceFrameRateEx(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapGetDeviceFrameRateEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  float * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapGetDeviceFrameRateEx", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapGetDeviceFrameRateEx(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapGetDeviceFrameRateEx _cffi_d_LeapGetDeviceFrameRateEx
#endif

static eLeapRS _cffi_d_LeapGetDeviceInfo(struct _LEAP_DEVICE * x0, LEAP_DEVICE_INFO * x1)
{
  return LeapGetDeviceInfo(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapGetDeviceInfo(PyObject *self, PyObject *args)
{
  struct _LEAP_DEVICE * x0;
  LEAP_DEVICE_INFO * x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LeapGetDeviceInfo", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(216), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (LEAP_DEVICE_INFO *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(216), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapGetDeviceInfo(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapGetDeviceInfo _cffi_d_LeapGetDeviceInfo
#endif

static eLeapRS _cffi_d_LeapGetDeviceList(struct _LEAP_CONNECTION * x0, LEAP_DEVICE_REF * x1, uint32_t * x2)
{
  return LeapGetDeviceList(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapGetDeviceList(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  LEAP_DEVICE_REF * x1;
  uint32_t * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapGetDeviceList", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(65), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (LEAP_DEVICE_REF *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(65), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(66), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (uint32_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(66), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapGetDeviceList(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapGetDeviceList _cffi_d_LeapGetDeviceList
#endif

static eLeapRS _cffi_d_LeapGetDeviceTransform(struct _LEAP_DEVICE * x0, float * x1)
{
  return LeapGetDeviceTransform(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapGetDeviceTransform(PyObject *self, PyObject *args)
{
  struct _LEAP_DEVICE * x0;
  float * x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LeapGetDeviceTransform", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapGetDeviceTransform(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapGetDeviceTransform _cffi_d_LeapGetDeviceTransform
#endif

static eLeapRS _cffi_d_LeapGetFrameSize(struct _LEAP_CONNECTION * x0, int64_t x1, uint64_t * x2)
{
  return LeapGetFrameSize(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapGetFrameSize(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  int64_t x1;
  uint64_t * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapGetFrameSize", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(71), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (uint64_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(71), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapGetFrameSize(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapGetFrameSize _cffi_d_LeapGetFrameSize
#endif

static eLeapRS _cffi_d_LeapGetFrameSizeEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, int64_t x2, uint64_t * x3)
{
  return LeapGetFrameSizeEx(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapGetFrameSizeEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  int64_t x2;
  uint64_t * x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "LeapGetFrameSizeEx", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(71), arg3, (char **)&x3);
  if (datasize != 0) {
    x3 = ((size_t)datasize) <= 640 ? (uint64_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(71), arg3, (char **)&x3,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapGetFrameSizeEx(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapGetFrameSizeEx _cffi_d_LeapGetFrameSizeEx
#endif

static int64_t _cffi_d_LeapGetNow(void)
{
  return LeapGetNow();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapGetNow(PyObject *self, PyObject *noarg)
{
  int64_t result;
  PyObject *pyresult;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapGetNow(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  return pyresult;
}
#else
#  define _cffi_f_LeapGetNow _cffi_d_LeapGetNow
#endif

static eLeapRS _cffi_d_LeapGetPointMapping(struct _LEAP_CONNECTION * x0, LEAP_POINT_MAPPING * x1, uint64_t * x2)
{
  return LeapGetPointMapping(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapGetPointMapping(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  LEAP_POINT_MAPPING * x1;
  uint64_t * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapGetPointMapping", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(70), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (LEAP_POINT_MAPPING *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(70), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(71), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (uint64_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(71), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapGetPointMapping(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapGetPointMapping _cffi_d_LeapGetPointMapping
#endif

static eLeapRS _cffi_d_LeapGetPointMappingSize(struct _LEAP_CONNECTION * x0, uint64_t * x1)
{
  return LeapGetPointMappingSize(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapGetPointMappingSize(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  uint64_t * x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LeapGetPointMappingSize", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(71), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (uint64_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(71), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapGetPointMappingSize(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapGetPointMappingSize _cffi_d_LeapGetPointMappingSize
#endif

static eLeapRS _cffi_d_LeapGetServerStatus(uint32_t x0, LEAP_SERVER_STATUS const * * x1)
{
  return LeapGetServerStatus(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapGetServerStatus(PyObject *self, PyObject *args)
{
  uint32_t x0;
  LEAP_SERVER_STATUS const * * x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LeapGetServerStatus", 2, 2, &arg0, &arg1))
    return NULL;

  x0 = _cffi_to_c_int(arg0, uint32_t);
  if (x0 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(254), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (LEAP_SERVER_STATUS const * *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(254), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapGetServerStatus(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapGetServerStatus _cffi_d_LeapGetServerStatus
#endif

static eLeapRS _cffi_d_LeapGetTrackingMode(struct _LEAP_CONNECTION * x0)
{
  return LeapGetTrackingMode(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapGetTrackingMode(PyObject *self, PyObject *arg0)
{
  struct _LEAP_CONNECTION * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapGetTrackingMode(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapGetTrackingMode _cffi_d_LeapGetTrackingMode
#endif

static eLeapRS _cffi_d_LeapGetTrackingModeEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1)
{
  return LeapGetTrackingModeEx(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapGetTrackingModeEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LeapGetTrackingModeEx", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapGetTrackingModeEx(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapGetTrackingModeEx _cffi_d_LeapGetTrackingModeEx
#endif

static eLeapRS _cffi_d_LeapGetVersion(struct _LEAP_CONNECTION * x0, eLeapVersionPart x1, LEAP_VERSION * x2)
{
  return LeapGetVersion(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapGetVersion(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  eLeapVersionPart x1;
  LEAP_VERSION * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapGetVersion", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x1, _cffi_type(108), arg1) < 0)
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(109), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (LEAP_VERSION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(109), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapGetVersion(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapGetVersion _cffi_d_LeapGetVersion
#endif

static eLeapRS _cffi_d_LeapInterpolateEyePositions(struct _LEAP_CONNECTION * x0, int64_t x1, LEAP_EYE_EVENT * x2)
{
  return LeapInterpolateEyePositions(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapInterpolateEyePositions(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  int64_t x1;
  LEAP_EYE_EVENT * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapInterpolateEyePositions", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(118), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (LEAP_EYE_EVENT *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(118), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapInterpolateEyePositions(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapInterpolateEyePositions _cffi_d_LeapInterpolateEyePositions
#endif

static eLeapRS _cffi_d_LeapInterpolateFrame(struct _LEAP_CONNECTION * x0, int64_t x1, LEAP_TRACKING_EVENT * x2, uint64_t x3)
{
  return LeapInterpolateFrame(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapInterpolateFrame(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  int64_t x1;
  LEAP_TRACKING_EVENT * x2;
  uint64_t x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "LeapInterpolateFrame", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(128), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (LEAP_TRACKING_EVENT *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(128), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, uint64_t);
  if (x3 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapInterpolateFrame(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapInterpolateFrame _cffi_d_LeapInterpolateFrame
#endif

static eLeapRS _cffi_d_LeapInterpolateFrameEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, int64_t x2, LEAP_TRACKING_EVENT * x3, uint64_t x4)
{
  return LeapInterpolateFrameEx(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapInterpolateFrameEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  int64_t x2;
  LEAP_TRACKING_EVENT * x3;
  uint64_t x4;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "LeapInterpolateFrameEx", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(128), arg3, (char **)&x3);
  if (datasize != 0) {
    x3 = ((size_t)datasize) <= 640 ? (LEAP_TRACKING_EVENT *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(128), arg3, (char **)&x3,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, uint64_t);
  if (x4 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapInterpolateFrameEx(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapInterpolateFrameEx _cffi_d_LeapInterpolateFrameEx
#endif

static eLeapRS _cffi_d_LeapInterpolateFrameFromTime(struct _LEAP_CONNECTION * x0, int64_t x1, int64_t x2, LEAP_TRACKING_EVENT * x3, uint64_t x4)
{
  return LeapInterpolateFrameFromTime(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapInterpolateFrameFromTime(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  int64_t x1;
  int64_t x2;
  LEAP_TRACKING_EVENT * x3;
  uint64_t x4;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "LeapInterpolateFrameFromTime", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(128), arg3, (char **)&x3);
  if (datasize != 0) {
    x3 = ((size_t)datasize) <= 640 ? (LEAP_TRACKING_EVENT *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(128), arg3, (char **)&x3,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, uint64_t);
  if (x4 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapInterpolateFrameFromTime(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapInterpolateFrameFromTime _cffi_d_LeapInterpolateFrameFromTime
#endif

static eLeapRS _cffi_d_LeapInterpolateFrameFromTimeEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, int64_t x2, int64_t x3, LEAP_TRACKING_EVENT * x4, uint64_t x5)
{
  return LeapInterpolateFrameFromTimeEx(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapInterpolateFrameFromTimeEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  int64_t x2;
  int64_t x3;
  LEAP_TRACKING_EVENT * x4;
  uint64_t x5;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "LeapInterpolateFrameFromTimeEx", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x3 = _cffi_to_c_int(arg3, int64_t);
  if (x3 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(128), arg4, (char **)&x4);
  if (datasize != 0) {
    x4 = ((size_t)datasize) <= 640 ? (LEAP_TRACKING_EVENT *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(128), arg4, (char **)&x4,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x5 = _cffi_to_c_int(arg5, uint64_t);
  if (x5 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapInterpolateFrameFromTimeEx(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapInterpolateFrameFromTimeEx _cffi_d_LeapInterpolateFrameFromTimeEx
#endif

static eLeapRS _cffi_d_LeapInterpolateHeadPose(struct _LEAP_CONNECTION * x0, int64_t x1, LEAP_HEAD_POSE_EVENT * x2)
{
  return LeapInterpolateHeadPose(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapInterpolateHeadPose(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  int64_t x1;
  LEAP_HEAD_POSE_EVENT * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapInterpolateHeadPose", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(123), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (LEAP_HEAD_POSE_EVENT *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(123), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapInterpolateHeadPose(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapInterpolateHeadPose _cffi_d_LeapInterpolateHeadPose
#endif

static eLeapRS _cffi_d_LeapInterpolateHeadPoseEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, int64_t x2, LEAP_HEAD_POSE_EVENT * x3)
{
  return LeapInterpolateHeadPoseEx(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapInterpolateHeadPoseEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  int64_t x2;
  LEAP_HEAD_POSE_EVENT * x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "LeapInterpolateHeadPoseEx", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(123), arg3, (char **)&x3);
  if (datasize != 0) {
    x3 = ((size_t)datasize) <= 640 ? (LEAP_HEAD_POSE_EVENT *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(123), arg3, (char **)&x3,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapInterpolateHeadPoseEx(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapInterpolateHeadPoseEx _cffi_d_LeapInterpolateHeadPoseEx
#endif

static eLeapRS _cffi_d_LeapOpenConnection(struct _LEAP_CONNECTION * x0)
{
  return LeapOpenConnection(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapOpenConnection(PyObject *self, PyObject *arg0)
{
  struct _LEAP_CONNECTION * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapOpenConnection(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapOpenConnection _cffi_d_LeapOpenConnection
#endif

static eLeapRS _cffi_d_LeapOpenDevice(LEAP_DEVICE_REF x0, struct _LEAP_DEVICE * * x1)
{
  return LeapOpenDevice(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapOpenDevice(PyObject *self, PyObject *args)
{
  LEAP_DEVICE_REF x0;
  struct _LEAP_DEVICE * * x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LeapOpenDevice", 2, 2, &arg0, &arg1))
    return NULL;

  if (_cffi_to_c((char *)&x0, _cffi_type(33), arg0) < 0)
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(34), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE * *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(34), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapOpenDevice(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
static eLeapRS _cffi_f_LeapOpenDevice(LEAP_DEVICE_REF *x0, struct _LEAP_DEVICE * * x1)
{
  eLeapRS result;
  { result = LeapOpenDevice(*x0, x1); }
  return result;
}
#endif

static LEAP_VECTOR _cffi_d_LeapPixelToRectilinear(struct _LEAP_CONNECTION * x0, eLeapPerspectiveType x1, LEAP_VECTOR x2)
{
  return LeapPixelToRectilinear(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapPixelToRectilinear(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  eLeapPerspectiveType x1;
  LEAP_VECTOR x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  LEAP_VECTOR result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapPixelToRectilinear", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x1, _cffi_type(2), arg1) < 0)
    return NULL;

  if (_cffi_to_c((char *)&x2, _cffi_type(3), arg2) < 0)
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapPixelToRectilinear(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_struct((char *)&result, _cffi_type(3));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
static void _cffi_f_LeapPixelToRectilinear(LEAP_VECTOR *result, struct _LEAP_CONNECTION * x0, eLeapPerspectiveType x1, LEAP_VECTOR *x2)
{
  { *result = LeapPixelToRectilinear(x0, x1, *x2); }
}
#endif

static LEAP_VECTOR _cffi_d_LeapPixelToRectilinearByIndex(struct _LEAP_CONNECTION * x0, uint8_t x1, LEAP_VECTOR x2)
{
  return LeapPixelToRectilinearByIndex(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapPixelToRectilinearByIndex(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  uint8_t x1;
  LEAP_VECTOR x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  LEAP_VECTOR result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapPixelToRectilinearByIndex", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint8_t);
  if (x1 == (uint8_t)-1 && PyErr_Occurred())
    return NULL;

  if (_cffi_to_c((char *)&x2, _cffi_type(3), arg2) < 0)
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapPixelToRectilinearByIndex(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_struct((char *)&result, _cffi_type(3));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
static void _cffi_f_LeapPixelToRectilinearByIndex(LEAP_VECTOR *result, struct _LEAP_CONNECTION * x0, uint8_t x1, LEAP_VECTOR *x2)
{
  { *result = LeapPixelToRectilinearByIndex(x0, x1, *x2); }
}
#endif

static LEAP_VECTOR _cffi_d_LeapPixelToRectilinearByIndexEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, uint8_t x2, LEAP_VECTOR x3)
{
  return LeapPixelToRectilinearByIndexEx(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapPixelToRectilinearByIndexEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  uint8_t x2;
  LEAP_VECTOR x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  LEAP_VECTOR result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "LeapPixelToRectilinearByIndexEx", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, uint8_t);
  if (x2 == (uint8_t)-1 && PyErr_Occurred())
    return NULL;

  if (_cffi_to_c((char *)&x3, _cffi_type(3), arg3) < 0)
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapPixelToRectilinearByIndexEx(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_struct((char *)&result, _cffi_type(3));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
static void _cffi_f_LeapPixelToRectilinearByIndexEx(LEAP_VECTOR *result, struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, uint8_t x2, LEAP_VECTOR *x3)
{
  { *result = LeapPixelToRectilinearByIndexEx(x0, x1, x2, *x3); }
}
#endif

static LEAP_VECTOR _cffi_d_LeapPixelToRectilinearEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, eLeapPerspectiveType x2, LEAP_VECTOR x3)
{
  return LeapPixelToRectilinearEx(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapPixelToRectilinearEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  eLeapPerspectiveType x2;
  LEAP_VECTOR x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  LEAP_VECTOR result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "LeapPixelToRectilinearEx", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x2, _cffi_type(2), arg2) < 0)
    return NULL;

  if (_cffi_to_c((char *)&x3, _cffi_type(3), arg3) < 0)
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapPixelToRectilinearEx(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_struct((char *)&result, _cffi_type(3));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
static void _cffi_f_LeapPixelToRectilinearEx(LEAP_VECTOR *result, struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, eLeapPerspectiveType x2, LEAP_VECTOR *x3)
{
  { *result = LeapPixelToRectilinearEx(x0, x1, x2, *x3); }
}
#endif

static eLeapRS _cffi_d_LeapPollConnection(struct _LEAP_CONNECTION * x0, uint32_t x1, LEAP_CONNECTION_MESSAGE * x2)
{
  return LeapPollConnection(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapPollConnection(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  uint32_t x1;
  LEAP_CONNECTION_MESSAGE * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapPollConnection", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint32_t);
  if (x1 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(203), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (LEAP_CONNECTION_MESSAGE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(203), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapPollConnection(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapPollConnection _cffi_d_LeapPollConnection
#endif

static eLeapRS _cffi_d_LeapRebaseClock(struct _LEAP_CLOCK_REBASER * x0, int64_t x1, int64_t * x2)
{
  return LeapRebaseClock(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapRebaseClock(PyObject *self, PyObject *args)
{
  struct _LEAP_CLOCK_REBASER * x0;
  int64_t x1;
  int64_t * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapRebaseClock", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(43), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CLOCK_REBASER *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(43), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(45), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (int64_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(45), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapRebaseClock(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapRebaseClock _cffi_d_LeapRebaseClock
#endif

static eLeapRS _cffi_d_LeapRecordingClose(struct _LEAP_RECORDING * * x0)
{
  return LeapRecordingClose(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapRecordingClose(PyObject *self, PyObject *arg0)
{
  struct _LEAP_RECORDING * * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(227), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_RECORDING * *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(227), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapRecordingClose(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapRecordingClose _cffi_d_LeapRecordingClose
#endif

static eLeapRS _cffi_d_LeapRecordingGetStatus(struct _LEAP_RECORDING * x0, LEAP_RECORDING_STATUS * x1)
{
  return LeapRecordingGetStatus(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapRecordingGetStatus(PyObject *self, PyObject *args)
{
  struct _LEAP_RECORDING * x0;
  LEAP_RECORDING_STATUS * x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LeapRecordingGetStatus", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(235), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_RECORDING *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(235), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(236), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (LEAP_RECORDING_STATUS *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(236), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapRecordingGetStatus(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapRecordingGetStatus _cffi_d_LeapRecordingGetStatus
#endif

static eLeapRS _cffi_d_LeapRecordingOpen(struct _LEAP_RECORDING * * x0, char const * x1, LEAP_RECORDING_PARAMETERS x2)
{
  return LeapRecordingOpen(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapRecordingOpen(PyObject *self, PyObject *args)
{
  struct _LEAP_RECORDING * * x0;
  char const * x1;
  LEAP_RECORDING_PARAMETERS x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapRecordingOpen", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(227), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_RECORDING * *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(227), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(83), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (char const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(83), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x2, _cffi_type(232), arg2) < 0)
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapRecordingOpen(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
static eLeapRS _cffi_f_LeapRecordingOpen(struct _LEAP_RECORDING * * x0, char const * x1, LEAP_RECORDING_PARAMETERS *x2)
{
  eLeapRS result;
  { result = LeapRecordingOpen(x0, x1, *x2); }
  return result;
}
#endif

static eLeapRS _cffi_d_LeapRecordingRead(struct _LEAP_RECORDING * x0, LEAP_TRACKING_EVENT * x1, uint64_t x2)
{
  return LeapRecordingRead(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapRecordingRead(PyObject *self, PyObject *args)
{
  struct _LEAP_RECORDING * x0;
  LEAP_TRACKING_EVENT * x1;
  uint64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapRecordingRead", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(235), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_RECORDING *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(235), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(128), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (LEAP_TRACKING_EVENT *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(128), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, uint64_t);
  if (x2 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapRecordingRead(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapRecordingRead _cffi_d_LeapRecordingRead
#endif

static eLeapRS _cffi_d_LeapRecordingReadSize(struct _LEAP_RECORDING * x0, uint64_t * x1)
{
  return LeapRecordingReadSize(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapRecordingReadSize(PyObject *self, PyObject *args)
{
  struct _LEAP_RECORDING * x0;
  uint64_t * x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LeapRecordingReadSize", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(235), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_RECORDING *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(235), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(71), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (uint64_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(71), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapRecordingReadSize(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapRecordingReadSize _cffi_d_LeapRecordingReadSize
#endif

static eLeapRS _cffi_d_LeapRecordingWrite(struct _LEAP_RECORDING * x0, LEAP_TRACKING_EVENT * x1, uint64_t * x2)
{
  return LeapRecordingWrite(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapRecordingWrite(PyObject *self, PyObject *args)
{
  struct _LEAP_RECORDING * x0;
  LEAP_TRACKING_EVENT * x1;
  uint64_t * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapRecordingWrite", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(235), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_RECORDING *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(235), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(128), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (LEAP_TRACKING_EVENT *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(128), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(71), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (uint64_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(71), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapRecordingWrite(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapRecordingWrite _cffi_d_LeapRecordingWrite
#endif

static LEAP_VECTOR _cffi_d_LeapRectilinearToPixel(struct _LEAP_CONNECTION * x0, eLeapPerspectiveType x1, LEAP_VECTOR x2)
{
  return LeapRectilinearToPixel(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapRectilinearToPixel(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  eLeapPerspectiveType x1;
  LEAP_VECTOR x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  LEAP_VECTOR result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapRectilinearToPixel", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x1, _cffi_type(2), arg1) < 0)
    return NULL;

  if (_cffi_to_c((char *)&x2, _cffi_type(3), arg2) < 0)
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapRectilinearToPixel(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_struct((char *)&result, _cffi_type(3));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
static void _cffi_f_LeapRectilinearToPixel(LEAP_VECTOR *result, struct _LEAP_CONNECTION * x0, eLeapPerspectiveType x1, LEAP_VECTOR *x2)
{
  { *result = LeapRectilinearToPixel(x0, x1, *x2); }
}
#endif

static LEAP_VECTOR _cffi_d_LeapRectilinearToPixelByIndex(struct _LEAP_CONNECTION * x0, uint8_t x1, LEAP_VECTOR x2)
{
  return LeapRectilinearToPixelByIndex(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapRectilinearToPixelByIndex(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  uint8_t x1;
  LEAP_VECTOR x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  LEAP_VECTOR result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapRectilinearToPixelByIndex", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint8_t);
  if (x1 == (uint8_t)-1 && PyErr_Occurred())
    return NULL;

  if (_cffi_to_c((char *)&x2, _cffi_type(3), arg2) < 0)
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapRectilinearToPixelByIndex(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_struct((char *)&result, _cffi_type(3));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
static void _cffi_f_LeapRectilinearToPixelByIndex(LEAP_VECTOR *result, struct _LEAP_CONNECTION * x0, uint8_t x1, LEAP_VECTOR *x2)
{
  { *result = LeapRectilinearToPixelByIndex(x0, x1, *x2); }
}
#endif

static LEAP_VECTOR _cffi_d_LeapRectilinearToPixelByIndexEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, uint8_t x2, LEAP_VECTOR x3)
{
  return LeapRectilinearToPixelByIndexEx(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapRectilinearToPixelByIndexEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  uint8_t x2;
  LEAP_VECTOR x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  LEAP_VECTOR result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "LeapRectilinearToPixelByIndexEx", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, uint8_t);
  if (x2 == (uint8_t)-1 && PyErr_Occurred())
    return NULL;

  if (_cffi_to_c((char *)&x3, _cffi_type(3), arg3) < 0)
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapRectilinearToPixelByIndexEx(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_struct((char *)&result, _cffi_type(3));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
static void _cffi_f_LeapRectilinearToPixelByIndexEx(LEAP_VECTOR *result, struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, uint8_t x2, LEAP_VECTOR *x3)
{
  { *result = LeapRectilinearToPixelByIndexEx(x0, x1, x2, *x3); }
}
#endif

static LEAP_VECTOR _cffi_d_LeapRectilinearToPixelEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, eLeapPerspectiveType x2, LEAP_VECTOR x3)
{
  return LeapRectilinearToPixelEx(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapRectilinearToPixelEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  eLeapPerspectiveType x2;
  LEAP_VECTOR x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  LEAP_VECTOR result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "LeapRectilinearToPixelEx", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x2, _cffi_type(2), arg2) < 0)
    return NULL;

  if (_cffi_to_c((char *)&x3, _cffi_type(3), arg3) < 0)
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapRectilinearToPixelEx(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_struct((char *)&result, _cffi_type(3));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
static void _cffi_f_LeapRectilinearToPixelEx(LEAP_VECTOR *result, struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, eLeapPerspectiveType x2, LEAP_VECTOR *x3)
{
  { *result = LeapRectilinearToPixelEx(x0, x1, x2, *x3); }
}
#endif

static eLeapRS _cffi_d_LeapReleaseServerStatus(LEAP_SERVER_STATUS const * x0)
{
  return LeapReleaseServerStatus(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapReleaseServerStatus(PyObject *self, PyObject *arg0)
{
  LEAP_SERVER_STATUS const * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(37), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (LEAP_SERVER_STATUS const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(37), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapReleaseServerStatus(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapReleaseServerStatus _cffi_d_LeapReleaseServerStatus
#endif

static eLeapRS _cffi_d_LeapRequestConfigValue(struct _LEAP_CONNECTION * x0, char const * x1, uint32_t * x2)
{
  return LeapRequestConfigValue(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapRequestConfigValue(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  char const * x1;
  uint32_t * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapRequestConfigValue", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(83), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (char const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(83), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(66), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (uint32_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(66), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapRequestConfigValue(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapRequestConfigValue _cffi_d_LeapRequestConfigValue
#endif

static eLeapRS _cffi_d_LeapSaveConfigValue(struct _LEAP_CONNECTION * x0, char const * x1, LEAP_VARIANT const * x2, uint32_t * x3)
{
  return LeapSaveConfigValue(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapSaveConfigValue(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  char const * x1;
  LEAP_VARIANT const * x2;
  uint32_t * x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "LeapSaveConfigValue", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(83), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (char const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(83), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(84), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (LEAP_VARIANT const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(84), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(66), arg3, (char **)&x3);
  if (datasize != 0) {
    x3 = ((size_t)datasize) <= 640 ? (uint32_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(66), arg3, (char **)&x3,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapSaveConfigValue(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapSaveConfigValue _cffi_d_LeapSaveConfigValue
#endif

static void _cffi_d_LeapScaleOffsetMatrix(struct _LEAP_CONNECTION * x0, eLeapPerspectiveType x1, float * x2)
{
  LeapScaleOffsetMatrix(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapScaleOffsetMatrix(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  eLeapPerspectiveType x1;
  float * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapScaleOffsetMatrix", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x1, _cffi_type(2), arg1) < 0)
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapScaleOffsetMatrix(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapScaleOffsetMatrix _cffi_d_LeapScaleOffsetMatrix
#endif

static void _cffi_d_LeapScaleOffsetMatrixByIndex(struct _LEAP_CONNECTION * x0, uint8_t x1, float * x2)
{
  LeapScaleOffsetMatrixByIndex(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapScaleOffsetMatrixByIndex(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  uint8_t x1;
  float * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapScaleOffsetMatrixByIndex", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint8_t);
  if (x1 == (uint8_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapScaleOffsetMatrixByIndex(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapScaleOffsetMatrixByIndex _cffi_d_LeapScaleOffsetMatrixByIndex
#endif

static void _cffi_d_LeapScaleOffsetMatrixByIndexEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, uint8_t x2, float * x3)
{
  LeapScaleOffsetMatrixByIndexEx(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapScaleOffsetMatrixByIndexEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  uint8_t x2;
  float * x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "LeapScaleOffsetMatrixByIndexEx", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, uint8_t);
  if (x2 == (uint8_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg3, (char **)&x3);
  if (datasize != 0) {
    x3 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg3, (char **)&x3,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapScaleOffsetMatrixByIndexEx(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapScaleOffsetMatrixByIndexEx _cffi_d_LeapScaleOffsetMatrixByIndexEx
#endif

static void _cffi_d_LeapScaleOffsetMatrixEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, eLeapPerspectiveType x2, float * x3)
{
  LeapScaleOffsetMatrixEx(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapScaleOffsetMatrixEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  eLeapPerspectiveType x2;
  float * x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "LeapScaleOffsetMatrixEx", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x2, _cffi_type(2), arg2) < 0)
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(113), arg3, (char **)&x3);
  if (datasize != 0) {
    x3 = ((size_t)datasize) <= 640 ? (float *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(113), arg3, (char **)&x3,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LeapScaleOffsetMatrixEx(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LeapScaleOffsetMatrixEx _cffi_d_LeapScaleOffsetMatrixEx
#endif

static eLeapRS _cffi_d_LeapSetAllocator(struct _LEAP_CONNECTION * x0, LEAP_ALLOCATOR const * x1)
{
  return LeapSetAllocator(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapSetAllocator(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  LEAP_ALLOCATOR const * x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LeapSetAllocator", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(57), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (LEAP_ALLOCATOR const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(57), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapSetAllocator(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapSetAllocator _cffi_d_LeapSetAllocator
#endif

static eLeapRS _cffi_d_LeapSetConnectionMetadata(struct _LEAP_CONNECTION * x0, char const * x1, size_t x2)
{
  return LeapSetConnectionMetadata(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapSetConnectionMetadata(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  char const * x1;
  size_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapSetConnectionMetadata", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(83), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (char const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(83), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapSetConnectionMetadata(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapSetConnectionMetadata _cffi_d_LeapSetConnectionMetadata
#endif

static eLeapRS _cffi_d_LeapSetDeviceHints(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, char const * * x2)
{
  return LeapSetDeviceHints(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapSetDeviceHints(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  char const * * x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapSetDeviceHints", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(155), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (char const * *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(155), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapSetDeviceHints(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapSetDeviceHints _cffi_d_LeapSetDeviceHints
#endif

static eLeapRS _cffi_d_LeapSetPause(struct _LEAP_CONNECTION * x0, _Bool x1)
{
  return LeapSetPause(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapSetPause(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  _Bool x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LeapSetPause", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (_Bool)_cffi_to_c__Bool(arg1);
  if (x1 == (_Bool)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapSetPause(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapSetPause _cffi_d_LeapSetPause
#endif

static eLeapRS _cffi_d_LeapSetPolicyFlags(struct _LEAP_CONNECTION * x0, uint64_t x1, uint64_t x2)
{
  return LeapSetPolicyFlags(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapSetPolicyFlags(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  uint64_t x1;
  uint64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapSetPolicyFlags", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint64_t);
  if (x1 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, uint64_t);
  if (x2 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapSetPolicyFlags(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapSetPolicyFlags _cffi_d_LeapSetPolicyFlags
#endif

static eLeapRS _cffi_d_LeapSetPolicyFlagsEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, uint64_t x2, uint64_t x3)
{
  return LeapSetPolicyFlagsEx(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapSetPolicyFlagsEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  uint64_t x2;
  uint64_t x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "LeapSetPolicyFlagsEx", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, uint64_t);
  if (x2 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  x3 = _cffi_to_c_int(arg3, uint64_t);
  if (x3 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapSetPolicyFlagsEx(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapSetPolicyFlagsEx _cffi_d_LeapSetPolicyFlagsEx
#endif

static eLeapRS _cffi_d_LeapSetPrimaryDevice(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, _Bool x2)
{
  return LeapSetPrimaryDevice(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapSetPrimaryDevice(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  _Bool x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapSetPrimaryDevice", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = (_Bool)_cffi_to_c__Bool(arg2);
  if (x2 == (_Bool)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapSetPrimaryDevice(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapSetPrimaryDevice _cffi_d_LeapSetPrimaryDevice
#endif

static eLeapRS _cffi_d_LeapSetTrackingMode(struct _LEAP_CONNECTION * x0, eLeapTrackingMode x1)
{
  return LeapSetTrackingMode(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapSetTrackingMode(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  eLeapTrackingMode x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LeapSetTrackingMode", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x1, _cffi_type(104), arg1) < 0)
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapSetTrackingMode(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapSetTrackingMode _cffi_d_LeapSetTrackingMode
#endif

static eLeapRS _cffi_d_LeapSetTrackingModeEx(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1, eLeapTrackingMode x2)
{
  return LeapSetTrackingModeEx(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapSetTrackingModeEx(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  eLeapTrackingMode x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapSetTrackingModeEx", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x2, _cffi_type(104), arg2) < 0)
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapSetTrackingModeEx(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapSetTrackingModeEx _cffi_d_LeapSetTrackingModeEx
#endif

static eLeapRS _cffi_d_LeapSubscribeEvents(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1)
{
  return LeapSubscribeEvents(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapSubscribeEvents(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LeapSubscribeEvents", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapSubscribeEvents(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapSubscribeEvents _cffi_d_LeapSubscribeEvents
#endif

static uint64_t _cffi_d_LeapTelemetryGetNow(void)
{
  return LeapTelemetryGetNow();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapTelemetryGetNow(PyObject *self, PyObject *noarg)
{
  uint64_t result;
  PyObject *pyresult;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapTelemetryGetNow(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  pyresult = _cffi_from_c_int(result, uint64_t);
  return pyresult;
}
#else
#  define _cffi_f_LeapTelemetryGetNow _cffi_d_LeapTelemetryGetNow
#endif

static eLeapRS _cffi_d_LeapTelemetryProfiling(struct _LEAP_CONNECTION * x0, LEAP_TELEMETRY_DATA const * x1)
{
  return LeapTelemetryProfiling(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapTelemetryProfiling(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  LEAP_TELEMETRY_DATA const * x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LeapTelemetryProfiling", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(75), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (LEAP_TELEMETRY_DATA const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(75), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapTelemetryProfiling(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapTelemetryProfiling _cffi_d_LeapTelemetryProfiling
#endif

static eLeapRS _cffi_d_LeapUnsubscribeEvents(struct _LEAP_CONNECTION * x0, struct _LEAP_DEVICE * x1)
{
  return LeapUnsubscribeEvents(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapUnsubscribeEvents(PyObject *self, PyObject *args)
{
  struct _LEAP_CONNECTION * x0;
  struct _LEAP_DEVICE * x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LeapUnsubscribeEvents", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CONNECTION *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct _LEAP_DEVICE *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(7), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapUnsubscribeEvents(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapUnsubscribeEvents _cffi_d_LeapUnsubscribeEvents
#endif

static eLeapRS _cffi_d_LeapUpdateRebase(struct _LEAP_CLOCK_REBASER * x0, int64_t x1, int64_t x2)
{
  return LeapUpdateRebase(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LeapUpdateRebase(PyObject *self, PyObject *args)
{
  struct _LEAP_CLOCK_REBASER * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  eLeapRS result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LeapUpdateRebase", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(43), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct _LEAP_CLOCK_REBASER *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(43), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LeapUpdateRebase(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_deref((char *)&result, _cffi_type(388));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LeapUpdateRebase _cffi_d_LeapUpdateRebase
#endif

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_ALLOCATOR(LEAP_ALLOCATOR *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { void *(* *tmp)(uint32_t, eLeapAllocatorType, void *) = &p->allocate; (void)tmp; }
  { void(* *tmp)(void *, void *) = &p->deallocate; (void)tmp; }
  { void * *tmp = &p->state; (void)tmp; }
}
struct _cffi_align__LEAP_ALLOCATOR { char x; LEAP_ALLOCATOR y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_BONE(LEAP_BONE *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { LEAP_VECTOR *tmp = &p->prev_joint; (void)tmp; }
  { LEAP_VECTOR *tmp = &p->next_joint; (void)tmp; }
  { float *tmp = &p->width; (void)tmp; }
  { LEAP_QUATERNION *tmp = &p->rotation; (void)tmp; }
}
struct _cffi_align__LEAP_BONE { char x; LEAP_BONE y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_CONFIG_CHANGE_EVENT(LEAP_CONFIG_CHANGE_EVENT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->requestID) | 0);  /* check that 'LEAP_CONFIG_CHANGE_EVENT.requestID' is an integer */
  (void)((p->status) | 0);  /* check that 'LEAP_CONFIG_CHANGE_EVENT.status' is an integer */
}
struct _cffi_align__LEAP_CONFIG_CHANGE_EVENT { char x; LEAP_CONFIG_CHANGE_EVENT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_CONFIG_RESPONSE_EVENT(LEAP_CONFIG_RESPONSE_EVENT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->requestID) | 0);  /* check that 'LEAP_CONFIG_RESPONSE_EVENT.requestID' is an integer */
  { LEAP_VARIANT *tmp = &p->value; (void)tmp; }
}
struct _cffi_align__LEAP_CONFIG_RESPONSE_EVENT { char x; LEAP_CONFIG_RESPONSE_EVENT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_CONNECTION_CONFIG(LEAP_CONNECTION_CONFIG *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->size) | 0);  /* check that 'LEAP_CONNECTION_CONFIG.size' is an integer */
  (void)((p->flags) | 0);  /* check that 'LEAP_CONNECTION_CONFIG.flags' is an integer */
  { char const * *tmp = &p->server_namespace; (void)tmp; }
  { eLeapTrackingOrigin *tmp = &p->tracking_origin; (void)tmp; }
}
struct _cffi_align__LEAP_CONNECTION_CONFIG { char x; LEAP_CONNECTION_CONFIG y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_CONNECTION_EVENT(LEAP_CONNECTION_EVENT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->flags) | 0);  /* check that 'LEAP_CONNECTION_EVENT.flags' is an integer */
}
struct _cffi_align__LEAP_CONNECTION_EVENT { char x; LEAP_CONNECTION_EVENT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_CONNECTION_INFO(LEAP_CONNECTION_INFO *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->size) | 0);  /* check that 'LEAP_CONNECTION_INFO.size' is an integer */
  { eLeapConnectionStatus *tmp = &p->status; (void)tmp; }
}
struct _cffi_align__LEAP_CONNECTION_INFO { char x; LEAP_CONNECTION_INFO y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_CONNECTION_LOST_EVENT(LEAP_CONNECTION_LOST_EVENT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->flags) | 0);  /* check that 'LEAP_CONNECTION_LOST_EVENT.flags' is an integer */
}
struct _cffi_align__LEAP_CONNECTION_LOST_EVENT { char x; LEAP_CONNECTION_LOST_EVENT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_CONNECTION_MESSAGE(LEAP_CONNECTION_MESSAGE *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->size) | 0);  /* check that 'LEAP_CONNECTION_MESSAGE.size' is an integer */
  { eLeapEventType *tmp = &p->type; (void)tmp; }
  { void const * *tmp = &p->pointer; (void)tmp; }
  { LEAP_CONNECTION_EVENT const * *tmp = &p->connection_event; (void)tmp; }
  { LEAP_CONNECTION_LOST_EVENT const * *tmp = &p->connection_lost_event; (void)tmp; }
  { LEAP_DEVICE_EVENT const * *tmp = &p->device_event; (void)tmp; }
  { LEAP_DEVICE_STATUS_CHANGE_EVENT const * *tmp = &p->device_status_change_event; (void)tmp; }
  { LEAP_POLICY_EVENT const * *tmp = &p->policy_event; (void)tmp; }
  { LEAP_DEVICE_FAILURE_EVENT const * *tmp = &p->device_failure_event; (void)tmp; }
  { LEAP_TRACKING_EVENT const * *tmp = &p->tracking_event; (void)tmp; }
  { LEAP_TRACKING_MODE_EVENT const * *tmp = &p->tracking_mode_event; (void)tmp; }
  { LEAP_LOG_EVENT const * *tmp = &p->log_event; (void)tmp; }
  { LEAP_LOG_EVENTS const * *tmp = &p->log_events; (void)tmp; }
  { LEAP_CONFIG_RESPONSE_EVENT const * *tmp = &p->config_response_event; (void)tmp; }
  { LEAP_CONFIG_CHANGE_EVENT const * *tmp = &p->config_change_event; (void)tmp; }
  { LEAP_DROPPED_FRAME_EVENT const * *tmp = &p->dropped_frame_event; (void)tmp; }
  { LEAP_IMAGE_EVENT const * *tmp = &p->image_event; (void)tmp; }
  { LEAP_POINT_MAPPING_CHANGE_EVENT const * *tmp = &p->point_mapping_change_event; (void)tmp; }
  { LEAP_HEAD_POSE_EVENT const * *tmp = &p->head_pose_event; (void)tmp; }
  { LEAP_EYE_EVENT const * *tmp = &p->eye_event; (void)tmp; }
  { LEAP_IMU_EVENT const * *tmp = &p->imu_event; (void)tmp; }
  { LEAP_NEW_DEVICE_TRANSFORM const * *tmp = &p->new_device_transform_event; (void)tmp; }
  (void)((p->device_id) | 0);  /* check that 'LEAP_CONNECTION_MESSAGE.device_id' is an integer */
}
struct _cffi_align__LEAP_CONNECTION_MESSAGE { char x; LEAP_CONNECTION_MESSAGE y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_DEVICE_EVENT(LEAP_DEVICE_EVENT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->flags) | 0);  /* check that 'LEAP_DEVICE_EVENT.flags' is an integer */
  { LEAP_DEVICE_REF *tmp = &p->device; (void)tmp; }
  (void)((p->status) | 0);  /* check that 'LEAP_DEVICE_EVENT.status' is an integer */
}
struct _cffi_align__LEAP_DEVICE_EVENT { char x; LEAP_DEVICE_EVENT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_DEVICE_FAILURE_EVENT(LEAP_DEVICE_FAILURE_EVENT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { eLeapDeviceStatus *tmp = &p->status; (void)tmp; }
  { struct _LEAP_DEVICE * *tmp = &p->hDevice; (void)tmp; }
}
struct _cffi_align__LEAP_DEVICE_FAILURE_EVENT { char x; LEAP_DEVICE_FAILURE_EVENT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_DEVICE_INFO(LEAP_DEVICE_INFO *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->size) | 0);  /* check that 'LEAP_DEVICE_INFO.size' is an integer */
  (void)((p->status) | 0);  /* check that 'LEAP_DEVICE_INFO.status' is an integer */
  (void)((p->caps) | 0);  /* check that 'LEAP_DEVICE_INFO.caps' is an integer */
  { eLeapDevicePID *tmp = &p->pid; (void)tmp; }
  (void)((p->baseline) | 0);  /* check that 'LEAP_DEVICE_INFO.baseline' is an integer */
  (void)((p->serial_length) | 0);  /* check that 'LEAP_DEVICE_INFO.serial_length' is an integer */
  { char * *tmp = &p->serial; (void)tmp; }
  { float *tmp = &p->h_fov; (void)tmp; }
  { float *tmp = &p->v_fov; (void)tmp; }
  (void)((p->range) | 0);  /* check that 'LEAP_DEVICE_INFO.range' is an integer */
}
struct _cffi_align__LEAP_DEVICE_INFO { char x; LEAP_DEVICE_INFO y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_DEVICE_REF(LEAP_DEVICE_REF *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { void * *tmp = &p->handle; (void)tmp; }
  (void)((p->id) | 0);  /* check that 'LEAP_DEVICE_REF.id' is an integer */
}
struct _cffi_align__LEAP_DEVICE_REF { char x; LEAP_DEVICE_REF y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_DEVICE_STATUS_CHANGE_EVENT(LEAP_DEVICE_STATUS_CHANGE_EVENT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { LEAP_DEVICE_REF *tmp = &p->device; (void)tmp; }
  (void)((p->last_status) | 0);  /* check that 'LEAP_DEVICE_STATUS_CHANGE_EVENT.last_status' is an integer */
  (void)((p->status) | 0);  /* check that 'LEAP_DEVICE_STATUS_CHANGE_EVENT.status' is an integer */
}
struct _cffi_align__LEAP_DEVICE_STATUS_CHANGE_EVENT { char x; LEAP_DEVICE_STATUS_CHANGE_EVENT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_DIGIT(LEAP_DIGIT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->finger_id) | 0);  /* check that 'LEAP_DIGIT.finger_id' is an integer */
  { LEAP_BONE(*tmp)[4] = &p->bones; (void)tmp; }
  { LEAP_BONE *tmp = &p->metacarpal; (void)tmp; }
  { LEAP_BONE *tmp = &p->proximal; (void)tmp; }
  { LEAP_BONE *tmp = &p->intermediate; (void)tmp; }
  { LEAP_BONE *tmp = &p->distal; (void)tmp; }
  (void)((p->is_extended) | 0);  /* check that 'LEAP_DIGIT.is_extended' is an integer */
}
struct _cffi_align__LEAP_DIGIT { char x; LEAP_DIGIT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_DISTORTION_MATRIX(LEAP_DISTORTION_MATRIX *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  /* cannot generate 'struct $2[64][64]' in field 'matrix': unknown type name */
}
struct _cffi_align__LEAP_DISTORTION_MATRIX { char x; LEAP_DISTORTION_MATRIX y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_DROPPED_FRAME_EVENT(LEAP_DROPPED_FRAME_EVENT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->frame_id) | 0);  /* check that 'LEAP_DROPPED_FRAME_EVENT.frame_id' is an integer */
  { eLeapDroppedFrameType *tmp = &p->type; (void)tmp; }
}
struct _cffi_align__LEAP_DROPPED_FRAME_EVENT { char x; LEAP_DROPPED_FRAME_EVENT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_EYE_EVENT(LEAP_EYE_EVENT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->frame_id) | 0);  /* check that 'LEAP_EYE_EVENT.frame_id' is an integer */
  (void)((p->timestamp) | 0);  /* check that 'LEAP_EYE_EVENT.timestamp' is an integer */
  { LEAP_VECTOR *tmp = &p->left_eye_position; (void)tmp; }
  { LEAP_VECTOR *tmp = &p->right_eye_position; (void)tmp; }
  { float *tmp = &p->left_eye_estimated_error; (void)tmp; }
  { float *tmp = &p->right_eye_estimated_error; (void)tmp; }
}
struct _cffi_align__LEAP_EYE_EVENT { char x; LEAP_EYE_EVENT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_FRAME_HEADER(LEAP_FRAME_HEADER *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { void * *tmp = &p->reserved; (void)tmp; }
  (void)((p->frame_id) | 0);  /* check that 'LEAP_FRAME_HEADER.frame_id' is an integer */
  (void)((p->timestamp) | 0);  /* check that 'LEAP_FRAME_HEADER.timestamp' is an integer */
}
struct _cffi_align__LEAP_FRAME_HEADER { char x; LEAP_FRAME_HEADER y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_HAND(LEAP_HAND *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->id) | 0);  /* check that 'LEAP_HAND.id' is an integer */
  (void)((p->flags) | 0);  /* check that 'LEAP_HAND.flags' is an integer */
  { eLeapHandType *tmp = &p->type; (void)tmp; }
  { float *tmp = &p->confidence; (void)tmp; }
  (void)((p->visible_time) | 0);  /* check that 'LEAP_HAND.visible_time' is an integer */
  { float *tmp = &p->pinch_distance; (void)tmp; }
  { float *tmp = &p->grab_angle; (void)tmp; }
  { float *tmp = &p->pinch_strength; (void)tmp; }
  { float *tmp = &p->grab_strength; (void)tmp; }
  { LEAP_PALM *tmp = &p->palm; (void)tmp; }
  { LEAP_DIGIT *tmp = &p->thumb; (void)tmp; }
  { LEAP_DIGIT *tmp = &p->index; (void)tmp; }
  { LEAP_DIGIT *tmp = &p->middle; (void)tmp; }
  { LEAP_DIGIT *tmp = &p->ring; (void)tmp; }
  { LEAP_DIGIT *tmp = &p->pinky; (void)tmp; }
  { LEAP_DIGIT(*tmp)[5] = &p->digits; (void)tmp; }
  { LEAP_BONE *tmp = &p->arm; (void)tmp; }
}
struct _cffi_align__LEAP_HAND { char x; LEAP_HAND y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_HEAD_POSE_EVENT(LEAP_HEAD_POSE_EVENT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->timestamp) | 0);  /* check that 'LEAP_HEAD_POSE_EVENT.timestamp' is an integer */
  { LEAP_VECTOR *tmp = &p->head_position; (void)tmp; }
  { LEAP_QUATERNION *tmp = &p->head_orientation; (void)tmp; }
  { LEAP_VECTOR *tmp = &p->head_linear_velocity; (void)tmp; }
  { LEAP_VECTOR *tmp = &p->head_angular_velocity; (void)tmp; }
}
struct _cffi_align__LEAP_HEAD_POSE_EVENT { char x; LEAP_HEAD_POSE_EVENT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_IMAGE(LEAP_IMAGE *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { LEAP_IMAGE_PROPERTIES *tmp = &p->properties; (void)tmp; }
  (void)((p->matrix_version) | 0);  /* check that 'LEAP_IMAGE.matrix_version' is an integer */
  { LEAP_DISTORTION_MATRIX * *tmp = &p->distortion_matrix; (void)tmp; }
  { void * *tmp = &p->data; (void)tmp; }
  (void)((p->offset) | 0);  /* check that 'LEAP_IMAGE.offset' is an integer */
}
struct _cffi_align__LEAP_IMAGE { char x; LEAP_IMAGE y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_IMAGE_EVENT(LEAP_IMAGE_EVENT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { LEAP_FRAME_HEADER *tmp = &p->info; (void)tmp; }
  { LEAP_IMAGE(*tmp)[2] = &p->image; (void)tmp; }
  { struct _LEAP_CALIBRATION * *tmp = &p->calib; (void)tmp; }
}
struct _cffi_align__LEAP_IMAGE_EVENT { char x; LEAP_IMAGE_EVENT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_IMAGE_FRAME_DESCRIPTION(LEAP_IMAGE_FRAME_DESCRIPTION *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->frame_id) | 0);  /* check that 'LEAP_IMAGE_FRAME_DESCRIPTION.frame_id' is an integer */
  { eLeapImageType *tmp = &p->type; (void)tmp; }
  (void)((p->buffer_len) | 0);  /* check that 'LEAP_IMAGE_FRAME_DESCRIPTION.buffer_len' is an integer */
  { void * *tmp = &p->pBuffer; (void)tmp; }
}
struct _cffi_align__LEAP_IMAGE_FRAME_DESCRIPTION { char x; LEAP_IMAGE_FRAME_DESCRIPTION y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_IMAGE_PROPERTIES(LEAP_IMAGE_PROPERTIES *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { eLeapImageType *tmp = &p->type; (void)tmp; }
  { eLeapImageFormat *tmp = &p->format; (void)tmp; }
  (void)((p->bpp) | 0);  /* check that 'LEAP_IMAGE_PROPERTIES.bpp' is an integer */
  (void)((p->width) | 0);  /* check that 'LEAP_IMAGE_PROPERTIES.width' is an integer */
  (void)((p->height) | 0);  /* check that 'LEAP_IMAGE_PROPERTIES.height' is an integer */
  { float *tmp = &p->x_scale; (void)tmp; }
  { float *tmp = &p->y_scale; (void)tmp; }
  { float *tmp = &p->x_offset; (void)tmp; }
  { float *tmp = &p->y_offset; (void)tmp; }
}
struct _cffi_align__LEAP_IMAGE_PROPERTIES { char x; LEAP_IMAGE_PROPERTIES y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_IMU_EVENT(LEAP_IMU_EVENT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->timestamp) | 0);  /* check that 'LEAP_IMU_EVENT.timestamp' is an integer */
  (void)((p->timestamp_hw) | 0);  /* check that 'LEAP_IMU_EVENT.timestamp_hw' is an integer */
  (void)((p->flags) | 0);  /* check that 'LEAP_IMU_EVENT.flags' is an integer */
  { LEAP_VECTOR *tmp = &p->accelerometer; (void)tmp; }
  { LEAP_VECTOR *tmp = &p->gyroscope; (void)tmp; }
  { float *tmp = &p->temperature; (void)tmp; }
}
struct _cffi_align__LEAP_IMU_EVENT { char x; LEAP_IMU_EVENT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_LOG_EVENT(LEAP_LOG_EVENT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { eLeapLogSeverity *tmp = &p->severity; (void)tmp; }
  (void)((p->timestamp) | 0);  /* check that 'LEAP_LOG_EVENT.timestamp' is an integer */
  { char const * *tmp = &p->message; (void)tmp; }
}
struct _cffi_align__LEAP_LOG_EVENT { char x; LEAP_LOG_EVENT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_LOG_EVENTS(LEAP_LOG_EVENTS *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->nEvents) | 0);  /* check that 'LEAP_LOG_EVENTS.nEvents' is an integer */
  { LEAP_LOG_EVENT * *tmp = &p->events; (void)tmp; }
}
struct _cffi_align__LEAP_LOG_EVENTS { char x; LEAP_LOG_EVENTS y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_MATRIX_3x3(LEAP_MATRIX_3x3 *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { LEAP_VECTOR(*tmp)[3] = &p->m; (void)tmp; }
}
struct _cffi_align__LEAP_MATRIX_3x3 { char x; LEAP_MATRIX_3x3 y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_NEW_DEVICE_TRANSFORM(LEAP_NEW_DEVICE_TRANSFORM *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->reserved) | 0);  /* check that 'LEAP_NEW_DEVICE_TRANSFORM.reserved' is an integer */
}
struct _cffi_align__LEAP_NEW_DEVICE_TRANSFORM { char x; LEAP_NEW_DEVICE_TRANSFORM y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_PALM(LEAP_PALM *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { LEAP_VECTOR *tmp = &p->position; (void)tmp; }
  { LEAP_VECTOR *tmp = &p->stabilized_position; (void)tmp; }
  { LEAP_VECTOR *tmp = &p->velocity; (void)tmp; }
  { LEAP_VECTOR *tmp = &p->normal; (void)tmp; }
  { float *tmp = &p->width; (void)tmp; }
  { LEAP_VECTOR *tmp = &p->direction; (void)tmp; }
  { LEAP_QUATERNION *tmp = &p->orientation; (void)tmp; }
}
struct _cffi_align__LEAP_PALM { char x; LEAP_PALM y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_POINT_MAPPING(LEAP_POINT_MAPPING *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->frame_id) | 0);  /* check that 'LEAP_POINT_MAPPING.frame_id' is an integer */
  (void)((p->timestamp) | 0);  /* check that 'LEAP_POINT_MAPPING.timestamp' is an integer */
  (void)((p->nPoints) | 0);  /* check that 'LEAP_POINT_MAPPING.nPoints' is an integer */
  { LEAP_VECTOR * *tmp = &p->pPoints; (void)tmp; }
  { uint32_t * *tmp = &p->pIDs; (void)tmp; }
}
struct _cffi_align__LEAP_POINT_MAPPING { char x; LEAP_POINT_MAPPING y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_POINT_MAPPING_CHANGE_EVENT(LEAP_POINT_MAPPING_CHANGE_EVENT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->frame_id) | 0);  /* check that 'LEAP_POINT_MAPPING_CHANGE_EVENT.frame_id' is an integer */
  (void)((p->timestamp) | 0);  /* check that 'LEAP_POINT_MAPPING_CHANGE_EVENT.timestamp' is an integer */
  (void)((p->nPoints) | 0);  /* check that 'LEAP_POINT_MAPPING_CHANGE_EVENT.nPoints' is an integer */
}
struct _cffi_align__LEAP_POINT_MAPPING_CHANGE_EVENT { char x; LEAP_POINT_MAPPING_CHANGE_EVENT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_POLICY_EVENT(LEAP_POLICY_EVENT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->reserved) | 0);  /* check that 'LEAP_POLICY_EVENT.reserved' is an integer */
  (void)((p->current_policy) | 0);  /* check that 'LEAP_POLICY_EVENT.current_policy' is an integer */
}
struct _cffi_align__LEAP_POLICY_EVENT { char x; LEAP_POLICY_EVENT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_QUATERNION(LEAP_QUATERNION *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { float(*tmp)[4] = &p->v; (void)tmp; }
  { float *tmp = &p->x; (void)tmp; }
  { float *tmp = &p->y; (void)tmp; }
  { float *tmp = &p->z; (void)tmp; }
  { float *tmp = &p->w; (void)tmp; }
}
struct _cffi_align__LEAP_QUATERNION { char x; LEAP_QUATERNION y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_RECORDING_PARAMETERS(LEAP_RECORDING_PARAMETERS *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->mode) | 0);  /* check that 'LEAP_RECORDING_PARAMETERS.mode' is an integer */
}
struct _cffi_align__LEAP_RECORDING_PARAMETERS { char x; LEAP_RECORDING_PARAMETERS y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_RECORDING_STATUS(LEAP_RECORDING_STATUS *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->mode) | 0);  /* check that 'LEAP_RECORDING_STATUS.mode' is an integer */
}
struct _cffi_align__LEAP_RECORDING_STATUS { char x; LEAP_RECORDING_STATUS y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_SERVER_STATUS(LEAP_SERVER_STATUS *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { char const * *tmp = &p->version; (void)tmp; }
  (void)((p->device_count) | 0);  /* check that 'LEAP_SERVER_STATUS.device_count' is an integer */
  { LEAP_SERVER_STATUS_DEVICE const * *tmp = &p->devices; (void)tmp; }
}
struct _cffi_align__LEAP_SERVER_STATUS { char x; LEAP_SERVER_STATUS y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_SERVER_STATUS_DEVICE(LEAP_SERVER_STATUS_DEVICE *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { char const * *tmp = &p->serial; (void)tmp; }
  { char const * *tmp = &p->type; (void)tmp; }
}
struct _cffi_align__LEAP_SERVER_STATUS_DEVICE { char x; LEAP_SERVER_STATUS_DEVICE y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_TELEMETRY_DATA(LEAP_TELEMETRY_DATA *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->thread_id) | 0);  /* check that 'LEAP_TELEMETRY_DATA.thread_id' is an integer */
  (void)((p->start_time) | 0);  /* check that 'LEAP_TELEMETRY_DATA.start_time' is an integer */
  (void)((p->end_time) | 0);  /* check that 'LEAP_TELEMETRY_DATA.end_time' is an integer */
  (void)((p->zone_depth) | 0);  /* check that 'LEAP_TELEMETRY_DATA.zone_depth' is an integer */
  { char const * *tmp = &p->file_name; (void)tmp; }
  (void)((p->line_number) | 0);  /* check that 'LEAP_TELEMETRY_DATA.line_number' is an integer */
  { char const * *tmp = &p->zone_name; (void)tmp; }
}
struct _cffi_align__LEAP_TELEMETRY_DATA { char x; LEAP_TELEMETRY_DATA y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_TRACKING_EVENT(LEAP_TRACKING_EVENT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { LEAP_FRAME_HEADER *tmp = &p->info; (void)tmp; }
  (void)((p->tracking_frame_id) | 0);  /* check that 'LEAP_TRACKING_EVENT.tracking_frame_id' is an integer */
  (void)((p->nHands) | 0);  /* check that 'LEAP_TRACKING_EVENT.nHands' is an integer */
  { LEAP_HAND * *tmp = &p->pHands; (void)tmp; }
  { float *tmp = &p->framerate; (void)tmp; }
}
struct _cffi_align__LEAP_TRACKING_EVENT { char x; LEAP_TRACKING_EVENT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_TRACKING_MODE_EVENT(LEAP_TRACKING_MODE_EVENT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->reserved) | 0);  /* check that 'LEAP_TRACKING_MODE_EVENT.reserved' is an integer */
  { eLeapTrackingMode *tmp = &p->current_tracking_mode; (void)tmp; }
}
struct _cffi_align__LEAP_TRACKING_MODE_EVENT { char x; LEAP_TRACKING_MODE_EVENT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_VARIANT(LEAP_VARIANT *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { eLeapValueType *tmp = &p->type; (void)tmp; }
  (void)((p->boolValue) | 0);  /* check that 'LEAP_VARIANT.boolValue' is an integer */
  (void)((p->iValue) | 0);  /* check that 'LEAP_VARIANT.iValue' is an integer */
  { float *tmp = &p->fValue; (void)tmp; }
  { char const * *tmp = &p->strValue; (void)tmp; }
}
struct _cffi_align__LEAP_VARIANT { char x; LEAP_VARIANT y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_VECTOR(LEAP_VECTOR *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { float(*tmp)[3] = &p->v; (void)tmp; }
  { float *tmp = &p->x; (void)tmp; }
  { float *tmp = &p->y; (void)tmp; }
  { float *tmp = &p->z; (void)tmp; }
}
struct _cffi_align__LEAP_VECTOR { char x; LEAP_VECTOR y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__LEAP_VERSION(LEAP_VERSION *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->major) | 0);  /* check that 'LEAP_VERSION.major' is an integer */
  (void)((p->minor) | 0);  /* check that 'LEAP_VERSION.minor' is an integer */
  (void)((p->patch) | 0);  /* check that 'LEAP_VERSION.patch' is an integer */
}
struct _cffi_align__LEAP_VERSION { char x; LEAP_VERSION y; };

static const struct _cffi_global_s _cffi_globals[] = {
  { "FORCE_DWORD", (void *)_cffi_const_FORCE_DWORD, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "LeapCameraMatrix", (void *)_cffi_f_LeapCameraMatrix, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 271), (void *)_cffi_d_LeapCameraMatrix },
  { "LeapCameraMatrixByIndex", (void *)_cffi_f_LeapCameraMatrixByIndex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 288), (void *)_cffi_d_LeapCameraMatrixByIndex },
  { "LeapCameraMatrixByIndexEx", (void *)_cffi_f_LeapCameraMatrixByIndexEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 282), (void *)_cffi_d_LeapCameraMatrixByIndexEx },
  { "LeapCameraMatrixEx", (void *)_cffi_f_LeapCameraMatrixEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 276), (void *)_cffi_d_LeapCameraMatrixEx },
  { "LeapCheckLicenseFlag", (void *)_cffi_f_LeapCheckLicenseFlag, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 87), (void *)_cffi_d_LeapCheckLicenseFlag },
  { "LeapCloseConnection", (void *)_cffi_f_LeapCloseConnection, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 268), (void *)_cffi_d_LeapCloseConnection },
  { "LeapCloseDevice", (void *)_cffi_f_LeapCloseDevice, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_LeapCloseDevice },
  { "LeapCreateClockRebaser", (void *)_cffi_f_LeapCreateClockRebaser, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 39), (void *)_cffi_d_LeapCreateClockRebaser },
  { "LeapCreateConnection", (void *)_cffi_f_LeapCreateConnection, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 28), (void *)_cffi_d_LeapCreateConnection },
  { "LeapDestroyClockRebaser", (void *)_cffi_f_LeapDestroyClockRebaser, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 265), (void *)_cffi_d_LeapDestroyClockRebaser },
  { "LeapDestroyConnection", (void *)_cffi_f_LeapDestroyConnection, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 268), (void *)_cffi_d_LeapDestroyConnection },
  { "LeapDevicePIDToString", (void *)_cffi_f_LeapDevicePIDToString, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 25), (void *)_cffi_d_LeapDevicePIDToString },
  { "LeapDeviceTransformAvailable", (void *)_cffi_f_LeapDeviceTransformAvailable, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 22), (void *)_cffi_d_LeapDeviceTransformAvailable },
  { "LeapDistortionCoeffs", (void *)_cffi_f_LeapDistortionCoeffs, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 271), (void *)_cffi_d_LeapDistortionCoeffs },
  { "LeapDistortionCoeffsByIndex", (void *)_cffi_f_LeapDistortionCoeffsByIndex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 288), (void *)_cffi_d_LeapDistortionCoeffsByIndex },
  { "LeapDistortionCoeffsByIndexEx", (void *)_cffi_f_LeapDistortionCoeffsByIndexEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 282), (void *)_cffi_d_LeapDistortionCoeffsByIndexEx },
  { "LeapDistortionCoeffsEx", (void *)_cffi_f_LeapDistortionCoeffsEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 276), (void *)_cffi_d_LeapDistortionCoeffsEx },
  { "LeapExtrinsicCameraMatrix", (void *)_cffi_f_LeapExtrinsicCameraMatrix, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 271), (void *)_cffi_d_LeapExtrinsicCameraMatrix },
  { "LeapExtrinsicCameraMatrixByIndex", (void *)_cffi_f_LeapExtrinsicCameraMatrixByIndex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 288), (void *)_cffi_d_LeapExtrinsicCameraMatrixByIndex },
  { "LeapExtrinsicCameraMatrixByIndexEx", (void *)_cffi_f_LeapExtrinsicCameraMatrixByIndexEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 282), (void *)_cffi_d_LeapExtrinsicCameraMatrixByIndexEx },
  { "LeapExtrinsicCameraMatrixEx", (void *)_cffi_f_LeapExtrinsicCameraMatrixEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 276), (void *)_cffi_d_LeapExtrinsicCameraMatrixEx },
  { "LeapGetConnectionInfo", (void *)_cffi_f_LeapGetConnectionInfo, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 59), (void *)_cffi_d_LeapGetConnectionInfo },
  { "LeapGetDeviceCameraCount", (void *)_cffi_f_LeapGetDeviceCameraCount, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 222), (void *)_cffi_d_LeapGetDeviceCameraCount },
  { "LeapGetDeviceFrameRate", (void *)_cffi_f_LeapGetDeviceFrameRate, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 111), (void *)_cffi_d_LeapGetDeviceFrameRate },
  { "LeapGetDeviceFrameRateEx", (void *)_cffi_f_LeapGetDeviceFrameRateEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 162), (void *)_cffi_d_LeapGetDeviceFrameRateEx },
  { "LeapGetDeviceInfo", (void *)_cffi_f_LeapGetDeviceInfo, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 214), (void *)_cffi_d_LeapGetDeviceInfo },
  { "LeapGetDeviceList", (void *)_cffi_f_LeapGetDeviceList, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 63), (void *)_cffi_d_LeapGetDeviceList },
  { "LeapGetDeviceTransform", (void *)_cffi_f_LeapGetDeviceTransform, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 218), (void *)_cffi_d_LeapGetDeviceTransform },
  { "LeapGetFrameSize", (void *)_cffi_f_LeapGetFrameSize, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 138), (void *)_cffi_d_LeapGetFrameSize },
  { "LeapGetFrameSizeEx", (void *)_cffi_f_LeapGetFrameSizeEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 188), (void *)_cffi_d_LeapGetFrameSizeEx },
  { "LeapGetNow", (void *)_cffi_f_LeapGetNow, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 256), (void *)_cffi_d_LeapGetNow },
  { "LeapGetPointMapping", (void *)_cffi_f_LeapGetPointMapping, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 68), (void *)_cffi_d_LeapGetPointMapping },
  { "LeapGetPointMappingSize", (void *)_cffi_f_LeapGetPointMappingSize, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 205), (void *)_cffi_d_LeapGetPointMappingSize },
  { "LeapGetServerStatus", (void *)_cffi_f_LeapGetServerStatus, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 252), (void *)_cffi_d_LeapGetServerStatus },
  { "LeapGetTrackingMode", (void *)_cffi_f_LeapGetTrackingMode, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 52), (void *)_cffi_d_LeapGetTrackingMode },
  { "LeapGetTrackingModeEx", (void *)_cffi_f_LeapGetTrackingModeEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 143), (void *)_cffi_d_LeapGetTrackingModeEx },
  { "LeapGetVersion", (void *)_cffi_f_LeapGetVersion, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 106), (void *)_cffi_d_LeapGetVersion },
  { "LeapInterpolateEyePositions", (void *)_cffi_f_LeapInterpolateEyePositions, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 115), (void *)_cffi_d_LeapInterpolateEyePositions },
  { "LeapInterpolateFrame", (void *)_cffi_f_LeapInterpolateFrame, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 125), (void *)_cffi_d_LeapInterpolateFrame },
  { "LeapInterpolateFrameEx", (void *)_cffi_f_LeapInterpolateFrameEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 173), (void *)_cffi_d_LeapInterpolateFrameEx },
  { "LeapInterpolateFrameFromTime", (void *)_cffi_f_LeapInterpolateFrameFromTime, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 131), (void *)_cffi_d_LeapInterpolateFrameFromTime },
  { "LeapInterpolateFrameFromTimeEx", (void *)_cffi_f_LeapInterpolateFrameFromTimeEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 180), (void *)_cffi_d_LeapInterpolateFrameFromTimeEx },
  { "LeapInterpolateHeadPose", (void *)_cffi_f_LeapInterpolateHeadPose, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 120), (void *)_cffi_d_LeapInterpolateHeadPose },
  { "LeapInterpolateHeadPoseEx", (void *)_cffi_f_LeapInterpolateHeadPoseEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 167), (void *)_cffi_d_LeapInterpolateHeadPoseEx },
  { "LeapOpenConnection", (void *)_cffi_f_LeapOpenConnection, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 52), (void *)_cffi_d_LeapOpenConnection },
  { "LeapOpenDevice", (void *)_cffi_f_LeapOpenDevice, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 32), (void *)_cffi_d_LeapOpenDevice },
  { "LeapPixelToRectilinear", (void *)_cffi_f_LeapPixelToRectilinear, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 0), (void *)_cffi_d_LeapPixelToRectilinear },
  { "LeapPixelToRectilinearByIndex", (void *)_cffi_f_LeapPixelToRectilinearByIndex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 17), (void *)_cffi_d_LeapPixelToRectilinearByIndex },
  { "LeapPixelToRectilinearByIndexEx", (void *)_cffi_f_LeapPixelToRectilinearByIndexEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 11), (void *)_cffi_d_LeapPixelToRectilinearByIndexEx },
  { "LeapPixelToRectilinearEx", (void *)_cffi_f_LeapPixelToRectilinearEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 5), (void *)_cffi_d_LeapPixelToRectilinearEx },
  { "LeapPollConnection", (void *)_cffi_f_LeapPollConnection, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 200), (void *)_cffi_d_LeapPollConnection },
  { "LeapRebaseClock", (void *)_cffi_f_LeapRebaseClock, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 42), (void *)_cffi_d_LeapRebaseClock },
  { "LeapRecordingClose", (void *)_cffi_f_LeapRecordingClose, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 226), (void *)_cffi_d_LeapRecordingClose },
  { "LeapRecordingGetStatus", (void *)_cffi_f_LeapRecordingGetStatus, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 234), (void *)_cffi_d_LeapRecordingGetStatus },
  { "LeapRecordingOpen", (void *)_cffi_f_LeapRecordingOpen, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 229), (void *)_cffi_d_LeapRecordingOpen },
  { "LeapRecordingRead", (void *)_cffi_f_LeapRecordingRead, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 243), (void *)_cffi_d_LeapRecordingRead },
  { "LeapRecordingReadSize", (void *)_cffi_f_LeapRecordingReadSize, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 248), (void *)_cffi_d_LeapRecordingReadSize },
  { "LeapRecordingWrite", (void *)_cffi_f_LeapRecordingWrite, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 238), (void *)_cffi_d_LeapRecordingWrite },
  { "LeapRectilinearToPixel", (void *)_cffi_f_LeapRectilinearToPixel, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 0), (void *)_cffi_d_LeapRectilinearToPixel },
  { "LeapRectilinearToPixelByIndex", (void *)_cffi_f_LeapRectilinearToPixelByIndex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 17), (void *)_cffi_d_LeapRectilinearToPixelByIndex },
  { "LeapRectilinearToPixelByIndexEx", (void *)_cffi_f_LeapRectilinearToPixelByIndexEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 11), (void *)_cffi_d_LeapRectilinearToPixelByIndexEx },
  { "LeapRectilinearToPixelEx", (void *)_cffi_f_LeapRectilinearToPixelEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 5), (void *)_cffi_d_LeapRectilinearToPixelEx },
  { "LeapReleaseServerStatus", (void *)_cffi_f_LeapReleaseServerStatus, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 36), (void *)_cffi_d_LeapReleaseServerStatus },
  { "LeapRequestConfigValue", (void *)_cffi_f_LeapRequestConfigValue, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 97), (void *)_cffi_d_LeapRequestConfigValue },
  { "LeapSaveConfigValue", (void *)_cffi_f_LeapSaveConfigValue, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 81), (void *)_cffi_d_LeapSaveConfigValue },
  { "LeapScaleOffsetMatrix", (void *)_cffi_f_LeapScaleOffsetMatrix, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 271), (void *)_cffi_d_LeapScaleOffsetMatrix },
  { "LeapScaleOffsetMatrixByIndex", (void *)_cffi_f_LeapScaleOffsetMatrixByIndex, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 288), (void *)_cffi_d_LeapScaleOffsetMatrixByIndex },
  { "LeapScaleOffsetMatrixByIndexEx", (void *)_cffi_f_LeapScaleOffsetMatrixByIndexEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 282), (void *)_cffi_d_LeapScaleOffsetMatrixByIndexEx },
  { "LeapScaleOffsetMatrixEx", (void *)_cffi_f_LeapScaleOffsetMatrixEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 276), (void *)_cffi_d_LeapScaleOffsetMatrixEx },
  { "LeapSetAllocator", (void *)_cffi_f_LeapSetAllocator, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 55), (void *)_cffi_d_LeapSetAllocator },
  { "LeapSetConnectionMetadata", (void *)_cffi_f_LeapSetConnectionMetadata, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 92), (void *)_cffi_d_LeapSetConnectionMetadata },
  { "LeapSetDeviceHints", (void *)_cffi_f_LeapSetDeviceHints, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 152), (void *)_cffi_d_LeapSetDeviceHints },
  { "LeapSetPause", (void *)_cffi_f_LeapSetPause, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 77), (void *)_cffi_d_LeapSetPause },
  { "LeapSetPolicyFlags", (void *)_cffi_f_LeapSetPolicyFlags, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 209), (void *)_cffi_d_LeapSetPolicyFlags },
  { "LeapSetPolicyFlagsEx", (void *)_cffi_f_LeapSetPolicyFlagsEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 194), (void *)_cffi_d_LeapSetPolicyFlagsEx },
  { "LeapSetPrimaryDevice", (void *)_cffi_f_LeapSetPrimaryDevice, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 147), (void *)_cffi_d_LeapSetPrimaryDevice },
  { "LeapSetTrackingMode", (void *)_cffi_f_LeapSetTrackingMode, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 102), (void *)_cffi_d_LeapSetTrackingMode },
  { "LeapSetTrackingModeEx", (void *)_cffi_f_LeapSetTrackingModeEx, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 157), (void *)_cffi_d_LeapSetTrackingModeEx },
  { "LeapSubscribeEvents", (void *)_cffi_f_LeapSubscribeEvents, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 143), (void *)_cffi_d_LeapSubscribeEvents },
  { "LeapTelemetryGetNow", (void *)_cffi_f_LeapTelemetryGetNow, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 258), (void *)_cffi_d_LeapTelemetryGetNow },
  { "LeapTelemetryProfiling", (void *)_cffi_f_LeapTelemetryProfiling, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 73), (void *)_cffi_d_LeapTelemetryProfiling },
  { "LeapUnsubscribeEvents", (void *)_cffi_f_LeapUnsubscribeEvents, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 143), (void *)_cffi_d_LeapUnsubscribeEvents },
  { "LeapUpdateRebase", (void *)_cffi_f_LeapUpdateRebase, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 47), (void *)_cffi_d_LeapUpdateRebase },
  { "eLeapAllocatorType_Double", (void *)_cffi_const_eLeapAllocatorType_Double, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapAllocatorType_Float", (void *)_cffi_const_eLeapAllocatorType_Float, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapAllocatorType_Int16", (void *)_cffi_const_eLeapAllocatorType_Int16, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapAllocatorType_Int32", (void *)_cffi_const_eLeapAllocatorType_Int32, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapAllocatorType_Int64", (void *)_cffi_const_eLeapAllocatorType_Int64, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapAllocatorType_Int8", (void *)_cffi_const_eLeapAllocatorType_Int8, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapAllocatorType_UInt16", (void *)_cffi_const_eLeapAllocatorType_UInt16, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapAllocatorType_UInt32", (void *)_cffi_const_eLeapAllocatorType_UInt32, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapAllocatorType_UInt64", (void *)_cffi_const_eLeapAllocatorType_UInt64, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapAllocatorType_Uint8", (void *)_cffi_const_eLeapAllocatorType_Uint8, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapCameraCalibrationType_infrared", (void *)_cffi_const_eLeapCameraCalibrationType_infrared, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapCameraCalibrationType_visual", (void *)_cffi_const_eLeapCameraCalibrationType_visual, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapConnectionConfig_MultiDeviceAware", (void *)_cffi_const_eLeapConnectionConfig_MultiDeviceAware, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapConnectionStatus_Connected", (void *)_cffi_const_eLeapConnectionStatus_Connected, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapConnectionStatus_HandshakeIncomplete", (void *)_cffi_const_eLeapConnectionStatus_HandshakeIncomplete, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapConnectionStatus_NotConnected", (void *)_cffi_const_eLeapConnectionStatus_NotConnected, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapConnectionStatus_NotRunning", (void *)_cffi_const_eLeapConnectionStatus_NotRunning, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDeviceCaps_Color", (void *)_cffi_const_eLeapDeviceCaps_Color, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDevicePID_3Di", (void *)_cffi_const_eLeapDevicePID_3Di, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDevicePID_Dragonfly", (void *)_cffi_const_eLeapDevicePID_Dragonfly, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDevicePID_Invalid", (void *)_cffi_const_eLeapDevicePID_Invalid, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDevicePID_LMC2", (void *)_cffi_const_eLeapDevicePID_LMC2, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDevicePID_Nightcrawler", (void *)_cffi_const_eLeapDevicePID_Nightcrawler, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDevicePID_Peripheral", (void *)_cffi_const_eLeapDevicePID_Peripheral, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDevicePID_Rigel", (void *)_cffi_const_eLeapDevicePID_Rigel, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDevicePID_SIR170", (void *)_cffi_const_eLeapDevicePID_SIR170, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDevicePID_Unknown", (void *)_cffi_const_eLeapDevicePID_Unknown, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDeviceStatus_BadCalibration", (void *)_cffi_const_eLeapDeviceStatus_BadCalibration, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDeviceStatus_BadControl", (void *)_cffi_const_eLeapDeviceStatus_BadControl, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDeviceStatus_BadFirmware", (void *)_cffi_const_eLeapDeviceStatus_BadFirmware, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDeviceStatus_BadTransport", (void *)_cffi_const_eLeapDeviceStatus_BadTransport, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDeviceStatus_LowResource", (void *)_cffi_const_eLeapDeviceStatus_LowResource, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDeviceStatus_Paused", (void *)_cffi_const_eLeapDeviceStatus_Paused, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDeviceStatus_Robust", (void *)_cffi_const_eLeapDeviceStatus_Robust, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDeviceStatus_Smudged", (void *)_cffi_const_eLeapDeviceStatus_Smudged, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDeviceStatus_Streaming", (void *)_cffi_const_eLeapDeviceStatus_Streaming, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDeviceStatus_UnknownFailure", (void *)_cffi_const_eLeapDeviceStatus_UnknownFailure, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDroppedFrameType_Other", (void *)_cffi_const_eLeapDroppedFrameType_Other, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDroppedFrameType_PreprocessingQueue", (void *)_cffi_const_eLeapDroppedFrameType_PreprocessingQueue, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapDroppedFrameType_TrackingQueue", (void *)_cffi_const_eLeapDroppedFrameType_TrackingQueue, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_ConfigChange", (void *)_cffi_const_eLeapEventType_ConfigChange, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_ConfigResponse", (void *)_cffi_const_eLeapEventType_ConfigResponse, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_Connection", (void *)_cffi_const_eLeapEventType_Connection, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_ConnectionLost", (void *)_cffi_const_eLeapEventType_ConnectionLost, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_Device", (void *)_cffi_const_eLeapEventType_Device, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_DeviceFailure", (void *)_cffi_const_eLeapEventType_DeviceFailure, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_DeviceLost", (void *)_cffi_const_eLeapEventType_DeviceLost, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_DeviceStatusChange", (void *)_cffi_const_eLeapEventType_DeviceStatusChange, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_DroppedFrame", (void *)_cffi_const_eLeapEventType_DroppedFrame, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_Eyes", (void *)_cffi_const_eLeapEventType_Eyes, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_HeadPose", (void *)_cffi_const_eLeapEventType_HeadPose, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_IMU", (void *)_cffi_const_eLeapEventType_IMU, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_Image", (void *)_cffi_const_eLeapEventType_Image, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_ImageComplete", (void *)_cffi_const_eLeapEventType_ImageComplete, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_ImageRequestError", (void *)_cffi_const_eLeapEventType_ImageRequestError, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_LogEvent", (void *)_cffi_const_eLeapEventType_LogEvent, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_LogEvents", (void *)_cffi_const_eLeapEventType_LogEvents, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_NewDeviceTransform", (void *)_cffi_const_eLeapEventType_NewDeviceTransform, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_None", (void *)_cffi_const_eLeapEventType_None, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_PointMappingChange", (void *)_cffi_const_eLeapEventType_PointMappingChange, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_Policy", (void *)_cffi_const_eLeapEventType_Policy, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_Tracking", (void *)_cffi_const_eLeapEventType_Tracking, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapEventType_TrackingMode", (void *)_cffi_const_eLeapEventType_TrackingMode, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapHandType_Left", (void *)_cffi_const_eLeapHandType_Left, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapHandType_Right", (void *)_cffi_const_eLeapHandType_Right, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapIMUFlag_HasAccelerometer", (void *)_cffi_const_eLeapIMUFlag_HasAccelerometer, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapIMUFlag_HasGyroscope", (void *)_cffi_const_eLeapIMUFlag_HasGyroscope, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapIMUFlag_HasTemperature", (void *)_cffi_const_eLeapIMUFlag_HasTemperature, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapImageFormat_IR", (void *)_cffi_const_eLeapImageFormat_IR, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapImageFormat_RGBIr_Bayer", (void *)_cffi_const_eLeapImageFormat_RGBIr_Bayer, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapImageFormat_UNKNOWN", (void *)_cffi_const_eLeapImageFormat_UNKNOWN, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapImageType_Default", (void *)_cffi_const_eLeapImageType_Default, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapImageType_Raw", (void *)_cffi_const_eLeapImageType_Raw, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapImageType_UNKNOWN", (void *)_cffi_const_eLeapImageType_UNKNOWN, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapLogSeverity_Critical", (void *)_cffi_const_eLeapLogSeverity_Critical, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapLogSeverity_Information", (void *)_cffi_const_eLeapLogSeverity_Information, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapLogSeverity_Unknown", (void *)_cffi_const_eLeapLogSeverity_Unknown, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapLogSeverity_Warning", (void *)_cffi_const_eLeapLogSeverity_Warning, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapPerspectiveType_invalid", (void *)_cffi_const_eLeapPerspectiveType_invalid, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapPerspectiveType_mono", (void *)_cffi_const_eLeapPerspectiveType_mono, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapPerspectiveType_stereo_left", (void *)_cffi_const_eLeapPerspectiveType_stereo_left, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapPerspectiveType_stereo_right", (void *)_cffi_const_eLeapPerspectiveType_stereo_right, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapPolicyFlag_AllowPauseResume", (void *)_cffi_const_eLeapPolicyFlag_AllowPauseResume, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapPolicyFlag_BackgroundFrames", (void *)_cffi_const_eLeapPolicyFlag_BackgroundFrames, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapPolicyFlag_Images", (void *)_cffi_const_eLeapPolicyFlag_Images, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapPolicyFlag_MapPoints", (void *)_cffi_const_eLeapPolicyFlag_MapPoints, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapPolicyFlag_OptimizeHMD", (void *)_cffi_const_eLeapPolicyFlag_OptimizeHMD, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapPolicyFlag_OptimizeScreenTop", (void *)_cffi_const_eLeapPolicyFlag_OptimizeScreenTop, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_BufferSizeOverflow", (void *)_cffi_const_eLeapRS_BufferSizeOverflow, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_CannotOpenDevice", (void *)_cffi_const_eLeapRS_CannotOpenDevice, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_ConcurrentPoll", (void *)_cffi_const_eLeapRS_ConcurrentPoll, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_HandshakeIncomplete", (void *)_cffi_const_eLeapRS_HandshakeIncomplete, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_InsufficientBuffer", (void *)_cffi_const_eLeapRS_InsufficientBuffer, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_InsufficientResources", (void *)_cffi_const_eLeapRS_InsufficientResources, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_InvalidArgument", (void *)_cffi_const_eLeapRS_InvalidArgument, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_InvalidClientID", (void *)_cffi_const_eLeapRS_InvalidClientID, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_NotAvailable", (void *)_cffi_const_eLeapRS_NotAvailable, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_NotConnected", (void *)_cffi_const_eLeapRS_NotConnected, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_NotStreaming", (void *)_cffi_const_eLeapRS_NotStreaming, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_ProtocolError", (void *)_cffi_const_eLeapRS_ProtocolError, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_RoutineIsNotSeer", (void *)_cffi_const_eLeapRS_RoutineIsNotSeer, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_Success", (void *)_cffi_const_eLeapRS_Success, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_Timeout", (void *)_cffi_const_eLeapRS_Timeout, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_TimestampTooEarly", (void *)_cffi_const_eLeapRS_TimestampTooEarly, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_UnexpectedClosed", (void *)_cffi_const_eLeapRS_UnexpectedClosed, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_UnknownError", (void *)_cffi_const_eLeapRS_UnknownError, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_UnknownImageFrameRequest", (void *)_cffi_const_eLeapRS_UnknownImageFrameRequest, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_UnknownTrackingFrameID", (void *)_cffi_const_eLeapRS_UnknownTrackingFrameID, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRS_Unsupported", (void *)_cffi_const_eLeapRS_Unsupported, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRecordingFlags_Compressed", (void *)_cffi_const_eLeapRecordingFlags_Compressed, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRecordingFlags_Error", (void *)_cffi_const_eLeapRecordingFlags_Error, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRecordingFlags_Flushing", (void *)_cffi_const_eLeapRecordingFlags_Flushing, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRecordingFlags_Reading", (void *)_cffi_const_eLeapRecordingFlags_Reading, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapRecordingFlags_Writing", (void *)_cffi_const_eLeapRecordingFlags_Writing, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapServiceState_ALL", (void *)_cffi_const_eLeapServiceState_ALL, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapServiceState_LowFpsDetected", (void *)_cffi_const_eLeapServiceState_LowFpsDetected, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapServiceState_PoorPerformancePause", (void *)_cffi_const_eLeapServiceState_PoorPerformancePause, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapServiceState_TrackingErrorUnknown", (void *)_cffi_const_eLeapServiceState_TrackingErrorUnknown, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapTrackingMode_Desktop", (void *)_cffi_const_eLeapTrackingMode_Desktop, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapTrackingMode_HMD", (void *)_cffi_const_eLeapTrackingMode_HMD, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapTrackingMode_ScreenTop", (void *)_cffi_const_eLeapTrackingMode_ScreenTop, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapTrackingMode_Unknown", (void *)_cffi_const_eLeapTrackingMode_Unknown, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapTrackingOrigin_DeviceCenter", (void *)_cffi_const_eLeapTrackingOrigin_DeviceCenter, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapTrackingOrigin_DevicePrimaryCamera", (void *)_cffi_const_eLeapTrackingOrigin_DevicePrimaryCamera, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapValueType_Boolean", (void *)_cffi_const_eLeapValueType_Boolean, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapValueType_Float", (void *)_cffi_const_eLeapValueType_Float, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapValueType_Int32", (void *)_cffi_const_eLeapValueType_Int32, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapValueType_String", (void *)_cffi_const_eLeapValueType_String, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapValueType_Unknown", (void *)_cffi_const_eLeapValueType_Unknown, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapVersionPart_ClientLibrary", (void *)_cffi_const_eLeapVersionPart_ClientLibrary, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapVersionPart_ClientProtocol", (void *)_cffi_const_eLeapVersionPart_ClientProtocol, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapVersionPart_ServerLibrary", (void *)_cffi_const_eLeapVersionPart_ServerLibrary, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "eLeapVersionPart_ServerProtocol", (void *)_cffi_const_eLeapVersionPart_ServerProtocol, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
};

static const struct _cffi_field_s _cffi_fields[] = {
  { "allocate", offsetof(LEAP_ALLOCATOR, allocate),
                sizeof(((LEAP_ALLOCATOR *)0)->allocate),
                _CFFI_OP(_CFFI_OP_NOOP, 411) },
  { "deallocate", offsetof(LEAP_ALLOCATOR, deallocate),
                  sizeof(((LEAP_ALLOCATOR *)0)->deallocate),
                  _CFFI_OP(_CFFI_OP_NOOP, 413) },
  { "state", offsetof(LEAP_ALLOCATOR, state),
             sizeof(((LEAP_ALLOCATOR *)0)->state),
             _CFFI_OP(_CFFI_OP_NOOP, 263) },
  { "prev_joint", offsetof(LEAP_BONE, prev_joint),
                  sizeof(((LEAP_BONE *)0)->prev_joint),
                  _CFFI_OP(_CFFI_OP_NOOP, 3) },
  { "next_joint", offsetof(LEAP_BONE, next_joint),
                  sizeof(((LEAP_BONE *)0)->next_joint),
                  _CFFI_OP(_CFFI_OP_NOOP, 3) },
  { "width", offsetof(LEAP_BONE, width),
             sizeof(((LEAP_BONE *)0)->width),
             _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "rotation", offsetof(LEAP_BONE, rotation),
                sizeof(((LEAP_BONE *)0)->rotation),
                _CFFI_OP(_CFFI_OP_NOOP, 359) },
  { "requestID", offsetof(LEAP_CONFIG_CHANGE_EVENT, requestID),
                 sizeof(((LEAP_CONFIG_CHANGE_EVENT *)0)->requestID),
                 _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "status", offsetof(LEAP_CONFIG_CHANGE_EVENT, status),
              sizeof(((LEAP_CONFIG_CHANGE_EVENT *)0)->status),
              _CFFI_OP(_CFFI_OP_NOOP, 79) },
  { "requestID", offsetof(LEAP_CONFIG_RESPONSE_EVENT, requestID),
                 sizeof(((LEAP_CONFIG_RESPONSE_EVENT *)0)->requestID),
                 _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "value", offsetof(LEAP_CONFIG_RESPONSE_EVENT, value),
             sizeof(((LEAP_CONFIG_RESPONSE_EVENT *)0)->value),
             _CFFI_OP(_CFFI_OP_NOOP, 369) },
  { "size", offsetof(LEAP_CONNECTION_CONFIG, size),
            sizeof(((LEAP_CONNECTION_CONFIG *)0)->size),
            _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "flags", offsetof(LEAP_CONNECTION_CONFIG, flags),
             sizeof(((LEAP_CONNECTION_CONFIG *)0)->flags),
             _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "server_namespace", offsetof(LEAP_CONNECTION_CONFIG, server_namespace),
                        sizeof(((LEAP_CONNECTION_CONFIG *)0)->server_namespace),
                        _CFFI_OP(_CFFI_OP_NOOP, 83) },
  { "tracking_origin", offsetof(LEAP_CONNECTION_CONFIG, tracking_origin),
                       sizeof(((LEAP_CONNECTION_CONFIG *)0)->tracking_origin),
                       _CFFI_OP(_CFFI_OP_NOOP, 391) },
  { "flags", offsetof(LEAP_CONNECTION_EVENT, flags),
             sizeof(((LEAP_CONNECTION_EVENT *)0)->flags),
             _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "size", offsetof(LEAP_CONNECTION_INFO, size),
            sizeof(((LEAP_CONNECTION_INFO *)0)->size),
            _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "status", offsetof(LEAP_CONNECTION_INFO, status),
              sizeof(((LEAP_CONNECTION_INFO *)0)->status),
              _CFFI_OP(_CFFI_OP_NOOP, 378) },
  { "flags", offsetof(LEAP_CONNECTION_LOST_EVENT, flags),
             sizeof(((LEAP_CONNECTION_LOST_EVENT *)0)->flags),
             _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "size", offsetof(LEAP_CONNECTION_MESSAGE, size),
            sizeof(((LEAP_CONNECTION_MESSAGE *)0)->size),
            _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "type", offsetof(LEAP_CONNECTION_MESSAGE, type),
            sizeof(((LEAP_CONNECTION_MESSAGE *)0)->type),
            _CFFI_OP(_CFFI_OP_NOOP, 381) },
  { "pointer", offsetof(LEAP_CONNECTION_MESSAGE, pointer),
               sizeof(((LEAP_CONNECTION_MESSAGE *)0)->pointer),
               _CFFI_OP(_CFFI_OP_NOOP, 412) },
  { "connection_event", offsetof(LEAP_CONNECTION_MESSAGE, connection_event),
                        sizeof(((LEAP_CONNECTION_MESSAGE *)0)->connection_event),
                        _CFFI_OP(_CFFI_OP_NOOP, 309) },
  { "connection_lost_event", offsetof(LEAP_CONNECTION_MESSAGE, connection_lost_event),
                             sizeof(((LEAP_CONNECTION_MESSAGE *)0)->connection_lost_event),
                             _CFFI_OP(_CFFI_OP_NOOP, 312) },
  { "device_event", offsetof(LEAP_CONNECTION_MESSAGE, device_event),
                    sizeof(((LEAP_CONNECTION_MESSAGE *)0)->device_event),
                    _CFFI_OP(_CFFI_OP_NOOP, 315) },
  { "device_status_change_event", offsetof(LEAP_CONNECTION_MESSAGE, device_status_change_event),
                                  sizeof(((LEAP_CONNECTION_MESSAGE *)0)->device_status_change_event),
                                  _CFFI_OP(_CFFI_OP_NOOP, 320) },
  { "policy_event", offsetof(LEAP_CONNECTION_MESSAGE, policy_event),
                    sizeof(((LEAP_CONNECTION_MESSAGE *)0)->policy_event),
                    _CFFI_OP(_CFFI_OP_NOOP, 357) },
  { "device_failure_event", offsetof(LEAP_CONNECTION_MESSAGE, device_failure_event),
                            sizeof(((LEAP_CONNECTION_MESSAGE *)0)->device_failure_event),
                            _CFFI_OP(_CFFI_OP_NOOP, 317) },
  { "tracking_event", offsetof(LEAP_CONNECTION_MESSAGE, tracking_event),
                      sizeof(((LEAP_CONNECTION_MESSAGE *)0)->tracking_event),
                      _CFFI_OP(_CFFI_OP_NOOP, 365) },
  { "tracking_mode_event", offsetof(LEAP_CONNECTION_MESSAGE, tracking_mode_event),
                           sizeof(((LEAP_CONNECTION_MESSAGE *)0)->tracking_mode_event),
                           _CFFI_OP(_CFFI_OP_NOOP, 367) },
  { "log_event", offsetof(LEAP_CONNECTION_MESSAGE, log_event),
                 sizeof(((LEAP_CONNECTION_MESSAGE *)0)->log_event),
                 _CFFI_OP(_CFFI_OP_NOOP, 346) },
  { "log_events", offsetof(LEAP_CONNECTION_MESSAGE, log_events),
                  sizeof(((LEAP_CONNECTION_MESSAGE *)0)->log_events),
                  _CFFI_OP(_CFFI_OP_NOOP, 348) },
  { "config_response_event", offsetof(LEAP_CONNECTION_MESSAGE, config_response_event),
                             sizeof(((LEAP_CONNECTION_MESSAGE *)0)->config_response_event),
                             _CFFI_OP(_CFFI_OP_NOOP, 306) },
  { "config_change_event", offsetof(LEAP_CONNECTION_MESSAGE, config_change_event),
                           sizeof(((LEAP_CONNECTION_MESSAGE *)0)->config_change_event),
                           _CFFI_OP(_CFFI_OP_NOOP, 304) },
  { "dropped_frame_event", offsetof(LEAP_CONNECTION_MESSAGE, dropped_frame_event),
                           sizeof(((LEAP_CONNECTION_MESSAGE *)0)->dropped_frame_event),
                           _CFFI_OP(_CFFI_OP_NOOP, 327) },
  { "image_event", offsetof(LEAP_CONNECTION_MESSAGE, image_event),
                   sizeof(((LEAP_CONNECTION_MESSAGE *)0)->image_event),
                   _CFFI_OP(_CFFI_OP_NOOP, 339) },
  { "point_mapping_change_event", offsetof(LEAP_CONNECTION_MESSAGE, point_mapping_change_event),
                                  sizeof(((LEAP_CONNECTION_MESSAGE *)0)->point_mapping_change_event),
                                  _CFFI_OP(_CFFI_OP_NOOP, 355) },
  { "head_pose_event", offsetof(LEAP_CONNECTION_MESSAGE, head_pose_event),
                       sizeof(((LEAP_CONNECTION_MESSAGE *)0)->head_pose_event),
                       _CFFI_OP(_CFFI_OP_NOOP, 334) },
  { "eye_event", offsetof(LEAP_CONNECTION_MESSAGE, eye_event),
                 sizeof(((LEAP_CONNECTION_MESSAGE *)0)->eye_event),
                 _CFFI_OP(_CFFI_OP_NOOP, 329) },
  { "imu_event", offsetof(LEAP_CONNECTION_MESSAGE, imu_event),
                 sizeof(((LEAP_CONNECTION_MESSAGE *)0)->imu_event),
                 _CFFI_OP(_CFFI_OP_NOOP, 343) },
  { "new_device_transform_event", offsetof(LEAP_CONNECTION_MESSAGE, new_device_transform_event),
                                  sizeof(((LEAP_CONNECTION_MESSAGE *)0)->new_device_transform_event),
                                  _CFFI_OP(_CFFI_OP_NOOP, 351) },
  { "device_id", offsetof(LEAP_CONNECTION_MESSAGE, device_id),
                 sizeof(((LEAP_CONNECTION_MESSAGE *)0)->device_id),
                 _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "flags", offsetof(LEAP_DEVICE_EVENT, flags),
             sizeof(((LEAP_DEVICE_EVENT *)0)->flags),
             _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "device", offsetof(LEAP_DEVICE_EVENT, device),
              sizeof(((LEAP_DEVICE_EVENT *)0)->device),
              _CFFI_OP(_CFFI_OP_NOOP, 33) },
  { "status", offsetof(LEAP_DEVICE_EVENT, status),
              sizeof(((LEAP_DEVICE_EVENT *)0)->status),
              _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "status", offsetof(LEAP_DEVICE_FAILURE_EVENT, status),
              sizeof(((LEAP_DEVICE_FAILURE_EVENT *)0)->status),
              _CFFI_OP(_CFFI_OP_NOOP, 379) },
  { "hDevice", offsetof(LEAP_DEVICE_FAILURE_EVENT, hDevice),
               sizeof(((LEAP_DEVICE_FAILURE_EVENT *)0)->hDevice),
               _CFFI_OP(_CFFI_OP_NOOP, 7) },
  { "size", offsetof(LEAP_DEVICE_INFO, size),
            sizeof(((LEAP_DEVICE_INFO *)0)->size),
            _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "status", offsetof(LEAP_DEVICE_INFO, status),
              sizeof(((LEAP_DEVICE_INFO *)0)->status),
              _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "caps", offsetof(LEAP_DEVICE_INFO, caps),
            sizeof(((LEAP_DEVICE_INFO *)0)->caps),
            _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "pid", offsetof(LEAP_DEVICE_INFO, pid),
           sizeof(((LEAP_DEVICE_INFO *)0)->pid),
           _CFFI_OP(_CFFI_OP_NOOP, 26) },
  { "baseline", offsetof(LEAP_DEVICE_INFO, baseline),
                sizeof(((LEAP_DEVICE_INFO *)0)->baseline),
                _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "serial_length", offsetof(LEAP_DEVICE_INFO, serial_length),
                     sizeof(((LEAP_DEVICE_INFO *)0)->serial_length),
                     _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "serial", offsetof(LEAP_DEVICE_INFO, serial),
              sizeof(((LEAP_DEVICE_INFO *)0)->serial),
              _CFFI_OP(_CFFI_OP_NOOP, 374) },
  { "h_fov", offsetof(LEAP_DEVICE_INFO, h_fov),
             sizeof(((LEAP_DEVICE_INFO *)0)->h_fov),
             _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "v_fov", offsetof(LEAP_DEVICE_INFO, v_fov),
             sizeof(((LEAP_DEVICE_INFO *)0)->v_fov),
             _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "range", offsetof(LEAP_DEVICE_INFO, range),
             sizeof(((LEAP_DEVICE_INFO *)0)->range),
             _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "handle", offsetof(LEAP_DEVICE_REF, handle),
              sizeof(((LEAP_DEVICE_REF *)0)->handle),
              _CFFI_OP(_CFFI_OP_NOOP, 263) },
  { "id", offsetof(LEAP_DEVICE_REF, id),
          sizeof(((LEAP_DEVICE_REF *)0)->id),
          _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "device", offsetof(LEAP_DEVICE_STATUS_CHANGE_EVENT, device),
              sizeof(((LEAP_DEVICE_STATUS_CHANGE_EVENT *)0)->device),
              _CFFI_OP(_CFFI_OP_NOOP, 33) },
  { "last_status", offsetof(LEAP_DEVICE_STATUS_CHANGE_EVENT, last_status),
                   sizeof(((LEAP_DEVICE_STATUS_CHANGE_EVENT *)0)->last_status),
                   _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "status", offsetof(LEAP_DEVICE_STATUS_CHANGE_EVENT, status),
              sizeof(((LEAP_DEVICE_STATUS_CHANGE_EVENT *)0)->status),
              _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "finger_id", offsetof(LEAP_DIGIT, finger_id),
                 sizeof(((LEAP_DIGIT *)0)->finger_id),
                 _CFFI_OP(_CFFI_OP_NOOP, 399) },
  { "bones", offsetof(LEAP_DIGIT, bones),
             sizeof(((LEAP_DIGIT *)0)->bones),
             _CFFI_OP(_CFFI_OP_NOOP, 302) },
  { "metacarpal", offsetof(LEAP_DIGIT, metacarpal),
                  sizeof(((LEAP_DIGIT *)0)->metacarpal),
                  _CFFI_OP(_CFFI_OP_NOOP, 301) },
  { "proximal", offsetof(LEAP_DIGIT, proximal),
                sizeof(((LEAP_DIGIT *)0)->proximal),
                _CFFI_OP(_CFFI_OP_NOOP, 301) },
  { "intermediate", offsetof(LEAP_DIGIT, intermediate),
                    sizeof(((LEAP_DIGIT *)0)->intermediate),
                    _CFFI_OP(_CFFI_OP_NOOP, 301) },
  { "distal", offsetof(LEAP_DIGIT, distal),
              sizeof(((LEAP_DIGIT *)0)->distal),
              _CFFI_OP(_CFFI_OP_NOOP, 301) },
  { "is_extended", offsetof(LEAP_DIGIT, is_extended),
                   sizeof(((LEAP_DIGIT *)0)->is_extended),
                   _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "matrix", offsetof(LEAP_DISTORTION_MATRIX, matrix),
              sizeof(((LEAP_DISTORTION_MATRIX *)0)->matrix),
              _CFFI_OP(_CFFI_OP_NOOP, 403) },
  { "frame_id", offsetof(LEAP_DROPPED_FRAME_EVENT, frame_id),
                sizeof(((LEAP_DROPPED_FRAME_EVENT *)0)->frame_id),
                _CFFI_OP(_CFFI_OP_NOOP, 44) },
  { "type", offsetof(LEAP_DROPPED_FRAME_EVENT, type),
            sizeof(((LEAP_DROPPED_FRAME_EVENT *)0)->type),
            _CFFI_OP(_CFFI_OP_NOOP, 380) },
  { "frame_id", offsetof(LEAP_EYE_EVENT, frame_id),
                sizeof(((LEAP_EYE_EVENT *)0)->frame_id),
                _CFFI_OP(_CFFI_OP_NOOP, 44) },
  { "timestamp", offsetof(LEAP_EYE_EVENT, timestamp),
                 sizeof(((LEAP_EYE_EVENT *)0)->timestamp),
                 _CFFI_OP(_CFFI_OP_NOOP, 44) },
  { "left_eye_position", offsetof(LEAP_EYE_EVENT, left_eye_position),
                         sizeof(((LEAP_EYE_EVENT *)0)->left_eye_position),
                         _CFFI_OP(_CFFI_OP_NOOP, 3) },
  { "right_eye_position", offsetof(LEAP_EYE_EVENT, right_eye_position),
                          sizeof(((LEAP_EYE_EVENT *)0)->right_eye_position),
                          _CFFI_OP(_CFFI_OP_NOOP, 3) },
  { "left_eye_estimated_error", offsetof(LEAP_EYE_EVENT, left_eye_estimated_error),
                                sizeof(((LEAP_EYE_EVENT *)0)->left_eye_estimated_error),
                                _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "right_eye_estimated_error", offsetof(LEAP_EYE_EVENT, right_eye_estimated_error),
                                 sizeof(((LEAP_EYE_EVENT *)0)->right_eye_estimated_error),
                                 _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "reserved", offsetof(LEAP_FRAME_HEADER, reserved),
                sizeof(((LEAP_FRAME_HEADER *)0)->reserved),
                _CFFI_OP(_CFFI_OP_NOOP, 263) },
  { "frame_id", offsetof(LEAP_FRAME_HEADER, frame_id),
                sizeof(((LEAP_FRAME_HEADER *)0)->frame_id),
                _CFFI_OP(_CFFI_OP_NOOP, 44) },
  { "timestamp", offsetof(LEAP_FRAME_HEADER, timestamp),
                 sizeof(((LEAP_FRAME_HEADER *)0)->timestamp),
                 _CFFI_OP(_CFFI_OP_NOOP, 44) },
  { "id", offsetof(LEAP_HAND, id),
          sizeof(((LEAP_HAND *)0)->id),
          _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "flags", offsetof(LEAP_HAND, flags),
             sizeof(((LEAP_HAND *)0)->flags),
             _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "type", offsetof(LEAP_HAND, type),
            sizeof(((LEAP_HAND *)0)->type),
            _CFFI_OP(_CFFI_OP_NOOP, 382) },
  { "confidence", offsetof(LEAP_HAND, confidence),
                  sizeof(((LEAP_HAND *)0)->confidence),
                  _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "visible_time", offsetof(LEAP_HAND, visible_time),
                    sizeof(((LEAP_HAND *)0)->visible_time),
                    _CFFI_OP(_CFFI_OP_NOOP, 129) },
  { "pinch_distance", offsetof(LEAP_HAND, pinch_distance),
                      sizeof(((LEAP_HAND *)0)->pinch_distance),
                      _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "grab_angle", offsetof(LEAP_HAND, grab_angle),
                  sizeof(((LEAP_HAND *)0)->grab_angle),
                  _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "pinch_strength", offsetof(LEAP_HAND, pinch_strength),
                      sizeof(((LEAP_HAND *)0)->pinch_strength),
                      _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "grab_strength", offsetof(LEAP_HAND, grab_strength),
                     sizeof(((LEAP_HAND *)0)->grab_strength),
                     _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "palm", offsetof(LEAP_HAND, palm),
            sizeof(((LEAP_HAND *)0)->palm),
            _CFFI_OP(_CFFI_OP_NOOP, 353) },
  { "thumb", offsetof(LEAP_HAND, thumb),
             sizeof(((LEAP_HAND *)0)->thumb),
             _CFFI_OP(_CFFI_OP_NOOP, 322) },
  { "index", offsetof(LEAP_HAND, index),
             sizeof(((LEAP_HAND *)0)->index),
             _CFFI_OP(_CFFI_OP_NOOP, 322) },
  { "middle", offsetof(LEAP_HAND, middle),
              sizeof(((LEAP_HAND *)0)->middle),
              _CFFI_OP(_CFFI_OP_NOOP, 322) },
  { "ring", offsetof(LEAP_HAND, ring),
            sizeof(((LEAP_HAND *)0)->ring),
            _CFFI_OP(_CFFI_OP_NOOP, 322) },
  { "pinky", offsetof(LEAP_HAND, pinky),
             sizeof(((LEAP_HAND *)0)->pinky),
             _CFFI_OP(_CFFI_OP_NOOP, 322) },
  { "digits", offsetof(LEAP_HAND, digits),
              sizeof(((LEAP_HAND *)0)->digits),
              _CFFI_OP(_CFFI_OP_NOOP, 323) },
  { "arm", offsetof(LEAP_HAND, arm),
           sizeof(((LEAP_HAND *)0)->arm),
           _CFFI_OP(_CFFI_OP_NOOP, 301) },
  { "timestamp", offsetof(LEAP_HEAD_POSE_EVENT, timestamp),
                 sizeof(((LEAP_HEAD_POSE_EVENT *)0)->timestamp),
                 _CFFI_OP(_CFFI_OP_NOOP, 44) },
  { "head_position", offsetof(LEAP_HEAD_POSE_EVENT, head_position),
                     sizeof(((LEAP_HEAD_POSE_EVENT *)0)->head_position),
                     _CFFI_OP(_CFFI_OP_NOOP, 3) },
  { "head_orientation", offsetof(LEAP_HEAD_POSE_EVENT, head_orientation),
                        sizeof(((LEAP_HEAD_POSE_EVENT *)0)->head_orientation),
                        _CFFI_OP(_CFFI_OP_NOOP, 359) },
  { "head_linear_velocity", offsetof(LEAP_HEAD_POSE_EVENT, head_linear_velocity),
                            sizeof(((LEAP_HEAD_POSE_EVENT *)0)->head_linear_velocity),
                            _CFFI_OP(_CFFI_OP_NOOP, 3) },
  { "head_angular_velocity", offsetof(LEAP_HEAD_POSE_EVENT, head_angular_velocity),
                             sizeof(((LEAP_HEAD_POSE_EVENT *)0)->head_angular_velocity),
                             _CFFI_OP(_CFFI_OP_NOOP, 3) },
  { "properties", offsetof(LEAP_IMAGE, properties),
                  sizeof(((LEAP_IMAGE *)0)->properties),
                  _CFFI_OP(_CFFI_OP_NOOP, 342) },
  { "matrix_version", offsetof(LEAP_IMAGE, matrix_version),
                      sizeof(((LEAP_IMAGE *)0)->matrix_version),
                      _CFFI_OP(_CFFI_OP_NOOP, 129) },
  { "distortion_matrix", offsetof(LEAP_IMAGE, distortion_matrix),
                         sizeof(((LEAP_IMAGE *)0)->distortion_matrix),
                         _CFFI_OP(_CFFI_OP_NOOP, 325) },
  { "data", offsetof(LEAP_IMAGE, data),
            sizeof(((LEAP_IMAGE *)0)->data),
            _CFFI_OP(_CFFI_OP_NOOP, 263) },
  { "offset", offsetof(LEAP_IMAGE, offset),
              sizeof(((LEAP_IMAGE *)0)->offset),
              _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "info", offsetof(LEAP_IMAGE_EVENT, info),
            sizeof(((LEAP_IMAGE_EVENT *)0)->info),
            _CFFI_OP(_CFFI_OP_NOOP, 331) },
  { "image", offsetof(LEAP_IMAGE_EVENT, image),
             sizeof(((LEAP_IMAGE_EVENT *)0)->image),
             _CFFI_OP(_CFFI_OP_NOOP, 337) },
  { "calib", offsetof(LEAP_IMAGE_EVENT, calib),
             sizeof(((LEAP_IMAGE_EVENT *)0)->calib),
             _CFFI_OP(_CFFI_OP_NOOP, 405) },
  { "frame_id", offsetof(LEAP_IMAGE_FRAME_DESCRIPTION, frame_id),
                sizeof(((LEAP_IMAGE_FRAME_DESCRIPTION *)0)->frame_id),
                _CFFI_OP(_CFFI_OP_NOOP, 44) },
  { "type", offsetof(LEAP_IMAGE_FRAME_DESCRIPTION, type),
            sizeof(((LEAP_IMAGE_FRAME_DESCRIPTION *)0)->type),
            _CFFI_OP(_CFFI_OP_NOOP, 385) },
  { "buffer_len", offsetof(LEAP_IMAGE_FRAME_DESCRIPTION, buffer_len),
                  sizeof(((LEAP_IMAGE_FRAME_DESCRIPTION *)0)->buffer_len),
                  _CFFI_OP(_CFFI_OP_NOOP, 129) },
  { "pBuffer", offsetof(LEAP_IMAGE_FRAME_DESCRIPTION, pBuffer),
               sizeof(((LEAP_IMAGE_FRAME_DESCRIPTION *)0)->pBuffer),
               _CFFI_OP(_CFFI_OP_NOOP, 263) },
  { "type", offsetof(LEAP_IMAGE_PROPERTIES, type),
            sizeof(((LEAP_IMAGE_PROPERTIES *)0)->type),
            _CFFI_OP(_CFFI_OP_NOOP, 385) },
  { "format", offsetof(LEAP_IMAGE_PROPERTIES, format),
              sizeof(((LEAP_IMAGE_PROPERTIES *)0)->format),
              _CFFI_OP(_CFFI_OP_NOOP, 384) },
  { "bpp", offsetof(LEAP_IMAGE_PROPERTIES, bpp),
           sizeof(((LEAP_IMAGE_PROPERTIES *)0)->bpp),
           _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "width", offsetof(LEAP_IMAGE_PROPERTIES, width),
             sizeof(((LEAP_IMAGE_PROPERTIES *)0)->width),
             _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "height", offsetof(LEAP_IMAGE_PROPERTIES, height),
              sizeof(((LEAP_IMAGE_PROPERTIES *)0)->height),
              _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "x_scale", offsetof(LEAP_IMAGE_PROPERTIES, x_scale),
               sizeof(((LEAP_IMAGE_PROPERTIES *)0)->x_scale),
               _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "y_scale", offsetof(LEAP_IMAGE_PROPERTIES, y_scale),
               sizeof(((LEAP_IMAGE_PROPERTIES *)0)->y_scale),
               _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "x_offset", offsetof(LEAP_IMAGE_PROPERTIES, x_offset),
                sizeof(((LEAP_IMAGE_PROPERTIES *)0)->x_offset),
                _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "y_offset", offsetof(LEAP_IMAGE_PROPERTIES, y_offset),
                sizeof(((LEAP_IMAGE_PROPERTIES *)0)->y_offset),
                _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "timestamp", offsetof(LEAP_IMU_EVENT, timestamp),
                 sizeof(((LEAP_IMU_EVENT *)0)->timestamp),
                 _CFFI_OP(_CFFI_OP_NOOP, 44) },
  { "timestamp_hw", offsetof(LEAP_IMU_EVENT, timestamp_hw),
                    sizeof(((LEAP_IMU_EVENT *)0)->timestamp_hw),
                    _CFFI_OP(_CFFI_OP_NOOP, 44) },
  { "flags", offsetof(LEAP_IMU_EVENT, flags),
             sizeof(((LEAP_IMU_EVENT *)0)->flags),
             _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "accelerometer", offsetof(LEAP_IMU_EVENT, accelerometer),
                     sizeof(((LEAP_IMU_EVENT *)0)->accelerometer),
                     _CFFI_OP(_CFFI_OP_NOOP, 3) },
  { "gyroscope", offsetof(LEAP_IMU_EVENT, gyroscope),
                 sizeof(((LEAP_IMU_EVENT *)0)->gyroscope),
                 _CFFI_OP(_CFFI_OP_NOOP, 3) },
  { "temperature", offsetof(LEAP_IMU_EVENT, temperature),
                   sizeof(((LEAP_IMU_EVENT *)0)->temperature),
                   _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "severity", offsetof(LEAP_LOG_EVENT, severity),
                sizeof(((LEAP_LOG_EVENT *)0)->severity),
                _CFFI_OP(_CFFI_OP_NOOP, 386) },
  { "timestamp", offsetof(LEAP_LOG_EVENT, timestamp),
                 sizeof(((LEAP_LOG_EVENT *)0)->timestamp),
                 _CFFI_OP(_CFFI_OP_NOOP, 44) },
  { "message", offsetof(LEAP_LOG_EVENT, message),
               sizeof(((LEAP_LOG_EVENT *)0)->message),
               _CFFI_OP(_CFFI_OP_NOOP, 83) },
  { "nEvents", offsetof(LEAP_LOG_EVENTS, nEvents),
               sizeof(((LEAP_LOG_EVENTS *)0)->nEvents),
               _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "events", offsetof(LEAP_LOG_EVENTS, events),
              sizeof(((LEAP_LOG_EVENTS *)0)->events),
              _CFFI_OP(_CFFI_OP_NOOP, 345) },
  { "m", offsetof(LEAP_MATRIX_3x3, m),
         sizeof(((LEAP_MATRIX_3x3 *)0)->m),
         _CFFI_OP(_CFFI_OP_NOOP, 371) },
  { "reserved", offsetof(LEAP_NEW_DEVICE_TRANSFORM, reserved),
                sizeof(((LEAP_NEW_DEVICE_TRANSFORM *)0)->reserved),
                _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "position", offsetof(LEAP_PALM, position),
                sizeof(((LEAP_PALM *)0)->position),
                _CFFI_OP(_CFFI_OP_NOOP, 3) },
  { "stabilized_position", offsetof(LEAP_PALM, stabilized_position),
                           sizeof(((LEAP_PALM *)0)->stabilized_position),
                           _CFFI_OP(_CFFI_OP_NOOP, 3) },
  { "velocity", offsetof(LEAP_PALM, velocity),
                sizeof(((LEAP_PALM *)0)->velocity),
                _CFFI_OP(_CFFI_OP_NOOP, 3) },
  { "normal", offsetof(LEAP_PALM, normal),
              sizeof(((LEAP_PALM *)0)->normal),
              _CFFI_OP(_CFFI_OP_NOOP, 3) },
  { "width", offsetof(LEAP_PALM, width),
             sizeof(((LEAP_PALM *)0)->width),
             _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "direction", offsetof(LEAP_PALM, direction),
                 sizeof(((LEAP_PALM *)0)->direction),
                 _CFFI_OP(_CFFI_OP_NOOP, 3) },
  { "orientation", offsetof(LEAP_PALM, orientation),
                   sizeof(((LEAP_PALM *)0)->orientation),
                   _CFFI_OP(_CFFI_OP_NOOP, 359) },
  { "frame_id", offsetof(LEAP_POINT_MAPPING, frame_id),
                sizeof(((LEAP_POINT_MAPPING *)0)->frame_id),
                _CFFI_OP(_CFFI_OP_NOOP, 44) },
  { "timestamp", offsetof(LEAP_POINT_MAPPING, timestamp),
                 sizeof(((LEAP_POINT_MAPPING *)0)->timestamp),
                 _CFFI_OP(_CFFI_OP_NOOP, 44) },
  { "nPoints", offsetof(LEAP_POINT_MAPPING, nPoints),
               sizeof(((LEAP_POINT_MAPPING *)0)->nPoints),
               _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "pPoints", offsetof(LEAP_POINT_MAPPING, pPoints),
               sizeof(((LEAP_POINT_MAPPING *)0)->pPoints),
               _CFFI_OP(_CFFI_OP_NOOP, 370) },
  { "pIDs", offsetof(LEAP_POINT_MAPPING, pIDs),
            sizeof(((LEAP_POINT_MAPPING *)0)->pIDs),
            _CFFI_OP(_CFFI_OP_NOOP, 66) },
  { "frame_id", offsetof(LEAP_POINT_MAPPING_CHANGE_EVENT, frame_id),
                sizeof(((LEAP_POINT_MAPPING_CHANGE_EVENT *)0)->frame_id),
                _CFFI_OP(_CFFI_OP_NOOP, 44) },
  { "timestamp", offsetof(LEAP_POINT_MAPPING_CHANGE_EVENT, timestamp),
                 sizeof(((LEAP_POINT_MAPPING_CHANGE_EVENT *)0)->timestamp),
                 _CFFI_OP(_CFFI_OP_NOOP, 44) },
  { "nPoints", offsetof(LEAP_POINT_MAPPING_CHANGE_EVENT, nPoints),
               sizeof(((LEAP_POINT_MAPPING_CHANGE_EVENT *)0)->nPoints),
               _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "reserved", offsetof(LEAP_POLICY_EVENT, reserved),
                sizeof(((LEAP_POLICY_EVENT *)0)->reserved),
                _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "current_policy", offsetof(LEAP_POLICY_EVENT, current_policy),
                      sizeof(((LEAP_POLICY_EVENT *)0)->current_policy),
                      _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "v", offsetof(LEAP_QUATERNION, v),
         sizeof(((LEAP_QUATERNION *)0)->v),
         _CFFI_OP(_CFFI_OP_NOOP, 397) },
  { "x", offsetof(LEAP_QUATERNION, x),
         sizeof(((LEAP_QUATERNION *)0)->x),
         _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "y", offsetof(LEAP_QUATERNION, y),
         sizeof(((LEAP_QUATERNION *)0)->y),
         _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "z", offsetof(LEAP_QUATERNION, z),
         sizeof(((LEAP_QUATERNION *)0)->z),
         _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "w", offsetof(LEAP_QUATERNION, w),
         sizeof(((LEAP_QUATERNION *)0)->w),
         _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "mode", offsetof(LEAP_RECORDING_PARAMETERS, mode),
            sizeof(((LEAP_RECORDING_PARAMETERS *)0)->mode),
            _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "mode", offsetof(LEAP_RECORDING_STATUS, mode),
            sizeof(((LEAP_RECORDING_STATUS *)0)->mode),
            _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "version", offsetof(LEAP_SERVER_STATUS, version),
               sizeof(((LEAP_SERVER_STATUS *)0)->version),
               _CFFI_OP(_CFFI_OP_NOOP, 83) },
  { "device_count", offsetof(LEAP_SERVER_STATUS, device_count),
                    sizeof(((LEAP_SERVER_STATUS *)0)->device_count),
                    _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "devices", offsetof(LEAP_SERVER_STATUS, devices),
               sizeof(((LEAP_SERVER_STATUS *)0)->devices),
               _CFFI_OP(_CFFI_OP_NOOP, 362) },
  { "serial", offsetof(LEAP_SERVER_STATUS_DEVICE, serial),
              sizeof(((LEAP_SERVER_STATUS_DEVICE *)0)->serial),
              _CFFI_OP(_CFFI_OP_NOOP, 83) },
  { "type", offsetof(LEAP_SERVER_STATUS_DEVICE, type),
            sizeof(((LEAP_SERVER_STATUS_DEVICE *)0)->type),
            _CFFI_OP(_CFFI_OP_NOOP, 83) },
  { "thread_id", offsetof(LEAP_TELEMETRY_DATA, thread_id),
                 sizeof(((LEAP_TELEMETRY_DATA *)0)->thread_id),
                 _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "start_time", offsetof(LEAP_TELEMETRY_DATA, start_time),
                  sizeof(((LEAP_TELEMETRY_DATA *)0)->start_time),
                  _CFFI_OP(_CFFI_OP_NOOP, 129) },
  { "end_time", offsetof(LEAP_TELEMETRY_DATA, end_time),
                sizeof(((LEAP_TELEMETRY_DATA *)0)->end_time),
                _CFFI_OP(_CFFI_OP_NOOP, 129) },
  { "zone_depth", offsetof(LEAP_TELEMETRY_DATA, zone_depth),
                  sizeof(((LEAP_TELEMETRY_DATA *)0)->zone_depth),
                  _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "file_name", offsetof(LEAP_TELEMETRY_DATA, file_name),
                 sizeof(((LEAP_TELEMETRY_DATA *)0)->file_name),
                 _CFFI_OP(_CFFI_OP_NOOP, 83) },
  { "line_number", offsetof(LEAP_TELEMETRY_DATA, line_number),
                   sizeof(((LEAP_TELEMETRY_DATA *)0)->line_number),
                   _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "zone_name", offsetof(LEAP_TELEMETRY_DATA, zone_name),
                 sizeof(((LEAP_TELEMETRY_DATA *)0)->zone_name),
                 _CFFI_OP(_CFFI_OP_NOOP, 83) },
  { "info", offsetof(LEAP_TRACKING_EVENT, info),
            sizeof(((LEAP_TRACKING_EVENT *)0)->info),
            _CFFI_OP(_CFFI_OP_NOOP, 331) },
  { "tracking_frame_id", offsetof(LEAP_TRACKING_EVENT, tracking_frame_id),
                         sizeof(((LEAP_TRACKING_EVENT *)0)->tracking_frame_id),
                         _CFFI_OP(_CFFI_OP_NOOP, 44) },
  { "nHands", offsetof(LEAP_TRACKING_EVENT, nHands),
              sizeof(((LEAP_TRACKING_EVENT *)0)->nHands),
              _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "pHands", offsetof(LEAP_TRACKING_EVENT, pHands),
              sizeof(((LEAP_TRACKING_EVENT *)0)->pHands),
              _CFFI_OP(_CFFI_OP_NOOP, 332) },
  { "framerate", offsetof(LEAP_TRACKING_EVENT, framerate),
                 sizeof(((LEAP_TRACKING_EVENT *)0)->framerate),
                 _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "reserved", offsetof(LEAP_TRACKING_MODE_EVENT, reserved),
                sizeof(((LEAP_TRACKING_MODE_EVENT *)0)->reserved),
                _CFFI_OP(_CFFI_OP_NOOP, 202) },
  { "current_tracking_mode", offsetof(LEAP_TRACKING_MODE_EVENT, current_tracking_mode),
                             sizeof(((LEAP_TRACKING_MODE_EVENT *)0)->current_tracking_mode),
                             _CFFI_OP(_CFFI_OP_NOOP, 104) },
  { "type", offsetof(LEAP_VARIANT, type),
            sizeof(((LEAP_VARIANT *)0)->type),
            _CFFI_OP(_CFFI_OP_NOOP, 392) },
  { "boolValue", offsetof(LEAP_VARIANT, boolValue),
                 sizeof(((LEAP_VARIANT *)0)->boolValue),
                 _CFFI_OP(_CFFI_OP_NOOP, 79) },
  { "iValue", offsetof(LEAP_VARIANT, iValue),
              sizeof(((LEAP_VARIANT *)0)->iValue),
              _CFFI_OP(_CFFI_OP_NOOP, 399) },
  { "fValue", offsetof(LEAP_VARIANT, fValue),
              sizeof(((LEAP_VARIANT *)0)->fValue),
              _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "strValue", offsetof(LEAP_VARIANT, strValue),
                sizeof(((LEAP_VARIANT *)0)->strValue),
                _CFFI_OP(_CFFI_OP_NOOP, 83) },
  { "v", offsetof(LEAP_VECTOR, v),
         sizeof(((LEAP_VECTOR *)0)->v),
         _CFFI_OP(_CFFI_OP_NOOP, 395) },
  { "x", offsetof(LEAP_VECTOR, x),
         sizeof(((LEAP_VECTOR *)0)->x),
         _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "y", offsetof(LEAP_VECTOR, y),
         sizeof(((LEAP_VECTOR *)0)->y),
         _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "z", offsetof(LEAP_VECTOR, z),
         sizeof(((LEAP_VECTOR *)0)->z),
         _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "major", offsetof(LEAP_VERSION, major),
             sizeof(((LEAP_VERSION *)0)->major),
             _CFFI_OP(_CFFI_OP_NOOP, 399) },
  { "minor", offsetof(LEAP_VERSION, minor),
             sizeof(((LEAP_VERSION *)0)->minor),
             _CFFI_OP(_CFFI_OP_NOOP, 399) },
  { "patch", offsetof(LEAP_VERSION, patch),
             sizeof(((LEAP_VERSION *)0)->patch),
             _CFFI_OP(_CFFI_OP_NOOP, 399) },
  { "x", (size_t)-1,
         (size_t)-1,
         _CFFI_OP(_CFFI_OP_NOOP, 394) },
  { "y", (size_t)-1,
         (size_t)-1,
         _CFFI_OP(_CFFI_OP_NOOP, 394) },
};

static const struct _cffi_struct_union_s _cffi_struct_unions[] = {
  { "$2", 400, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    (size_t)-2, -2, 192, 2 /* unnamed */ },
  { "LEAP_ALLOCATOR", 300, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_ALLOCATOR), offsetof(struct _cffi_align__LEAP_ALLOCATOR, y), 0, 3 },
  { "_LEAP_BONE", 301, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_BONE), offsetof(struct _cffi_align__LEAP_BONE, y), 3, 4 },
  { "_LEAP_CALIBRATION", 406, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "_LEAP_CLOCK_REBASER", 407, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "_LEAP_CONFIG_CHANGE_EVENT", 305, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_CONFIG_CHANGE_EVENT), offsetof(struct _cffi_align__LEAP_CONFIG_CHANGE_EVENT, y), 7, 2 },
  { "_LEAP_CONFIG_RESPONSE_EVENT", 307, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_CONFIG_RESPONSE_EVENT), offsetof(struct _cffi_align__LEAP_CONFIG_RESPONSE_EVENT, y), 9, 2 },
  { "_LEAP_CONNECTION", 408, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "_LEAP_CONNECTION_CONFIG", 308, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_CONNECTION_CONFIG), offsetof(struct _cffi_align__LEAP_CONNECTION_CONFIG, y), 11, 4 },
  { "_LEAP_CONNECTION_EVENT", 310, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_CONNECTION_EVENT), offsetof(struct _cffi_align__LEAP_CONNECTION_EVENT, y), 15, 1 },
  { "_LEAP_CONNECTION_INFO", 311, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_CONNECTION_INFO), offsetof(struct _cffi_align__LEAP_CONNECTION_INFO, y), 16, 2 },
  { "_LEAP_CONNECTION_LOST_EVENT", 313, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_CONNECTION_LOST_EVENT), offsetof(struct _cffi_align__LEAP_CONNECTION_LOST_EVENT, y), 18, 1 },
  { "_LEAP_CONNECTION_MESSAGE", 314, _CFFI_F_PACKED,
    sizeof(LEAP_CONNECTION_MESSAGE), offsetof(struct _cffi_align__LEAP_CONNECTION_MESSAGE, y), 19, 23 },
  { "_LEAP_DEVICE", 409, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "_LEAP_DEVICE_EVENT", 316, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_DEVICE_EVENT), offsetof(struct _cffi_align__LEAP_DEVICE_EVENT, y), 42, 3 },
  { "_LEAP_DEVICE_FAILURE_EVENT", 318, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_DEVICE_FAILURE_EVENT), offsetof(struct _cffi_align__LEAP_DEVICE_FAILURE_EVENT, y), 45, 2 },
  { "_LEAP_DEVICE_INFO", 319, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_DEVICE_INFO), offsetof(struct _cffi_align__LEAP_DEVICE_INFO, y), 47, 10 },
  { "_LEAP_DEVICE_REF", 33, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_DEVICE_REF), offsetof(struct _cffi_align__LEAP_DEVICE_REF, y), 57, 2 },
  { "_LEAP_DEVICE_STATUS_CHANGE_EVENT", 321, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_DEVICE_STATUS_CHANGE_EVENT), offsetof(struct _cffi_align__LEAP_DEVICE_STATUS_CHANGE_EVENT, y), 59, 3 },
  { "_LEAP_DIGIT", 322, _CFFI_F_PACKED,
    sizeof(LEAP_DIGIT), offsetof(struct _cffi_align__LEAP_DIGIT, y), 62, 7 },
  { "_LEAP_DISTORTION_MATRIX", 326, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_DISTORTION_MATRIX), offsetof(struct _cffi_align__LEAP_DISTORTION_MATRIX, y), 69, 1 },
  { "_LEAP_DROPPED_FRAME_EVENT", 328, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_DROPPED_FRAME_EVENT), offsetof(struct _cffi_align__LEAP_DROPPED_FRAME_EVENT, y), 70, 2 },
  { "_LEAP_EYE_EVENT", 330, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_EYE_EVENT), offsetof(struct _cffi_align__LEAP_EYE_EVENT, y), 72, 6 },
  { "_LEAP_FRAME_HEADER", 331, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_FRAME_HEADER), offsetof(struct _cffi_align__LEAP_FRAME_HEADER, y), 78, 3 },
  { "_LEAP_HAND", 333, _CFFI_F_PACKED,
    sizeof(LEAP_HAND), offsetof(struct _cffi_align__LEAP_HAND, y), 81, 17 },
  { "_LEAP_HEAD_POSE_EVENT", 335, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_HEAD_POSE_EVENT), offsetof(struct _cffi_align__LEAP_HEAD_POSE_EVENT, y), 98, 5 },
  { "_LEAP_IMAGE", 336, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_IMAGE), offsetof(struct _cffi_align__LEAP_IMAGE, y), 103, 5 },
  { "_LEAP_IMAGE_EVENT", 340, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_IMAGE_EVENT), offsetof(struct _cffi_align__LEAP_IMAGE_EVENT, y), 108, 3 },
  { "_LEAP_IMAGE_FRAME_DESCRIPTION", 341, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_IMAGE_FRAME_DESCRIPTION), offsetof(struct _cffi_align__LEAP_IMAGE_FRAME_DESCRIPTION, y), 111, 4 },
  { "_LEAP_IMAGE_PROPERTIES", 342, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_IMAGE_PROPERTIES), offsetof(struct _cffi_align__LEAP_IMAGE_PROPERTIES, y), 115, 9 },
  { "_LEAP_IMU_EVENT", 344, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_IMU_EVENT), offsetof(struct _cffi_align__LEAP_IMU_EVENT, y), 124, 6 },
  { "_LEAP_LOG_EVENT", 347, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_LOG_EVENT), offsetof(struct _cffi_align__LEAP_LOG_EVENT, y), 130, 3 },
  { "_LEAP_LOG_EVENTS", 349, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_LOG_EVENTS), offsetof(struct _cffi_align__LEAP_LOG_EVENTS, y), 133, 2 },
  { "_LEAP_MATRIX_3x3", 350, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_MATRIX_3x3), offsetof(struct _cffi_align__LEAP_MATRIX_3x3, y), 135, 1 },
  { "_LEAP_NEW_DEVICE_TRANSFORM", 352, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_NEW_DEVICE_TRANSFORM), offsetof(struct _cffi_align__LEAP_NEW_DEVICE_TRANSFORM, y), 136, 1 },
  { "_LEAP_PALM", 353, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_PALM), offsetof(struct _cffi_align__LEAP_PALM, y), 137, 7 },
  { "_LEAP_POINT_MAPPING", 354, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_POINT_MAPPING), offsetof(struct _cffi_align__LEAP_POINT_MAPPING, y), 144, 5 },
  { "_LEAP_POINT_MAPPING_CHANGE_EVENT", 356, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_POINT_MAPPING_CHANGE_EVENT), offsetof(struct _cffi_align__LEAP_POINT_MAPPING_CHANGE_EVENT, y), 149, 3 },
  { "_LEAP_POLICY_EVENT", 358, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_POLICY_EVENT), offsetof(struct _cffi_align__LEAP_POLICY_EVENT, y), 152, 2 },
  { "_LEAP_QUATERNION", 359, _CFFI_F_PACKED,
    sizeof(LEAP_QUATERNION), offsetof(struct _cffi_align__LEAP_QUATERNION, y), 154, 5 },
  { "_LEAP_RECORDING", 410, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "_LEAP_RECORDING_PARAMETERS", 232, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_RECORDING_PARAMETERS), offsetof(struct _cffi_align__LEAP_RECORDING_PARAMETERS, y), 159, 1 },
  { "_LEAP_RECORDING_STATUS", 360, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_RECORDING_STATUS), offsetof(struct _cffi_align__LEAP_RECORDING_STATUS, y), 160, 1 },
  { "_LEAP_SERVER_STATUS", 361, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_SERVER_STATUS), offsetof(struct _cffi_align__LEAP_SERVER_STATUS, y), 161, 3 },
  { "_LEAP_SERVER_STATUS_DEVICE", 363, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_SERVER_STATUS_DEVICE), offsetof(struct _cffi_align__LEAP_SERVER_STATUS_DEVICE, y), 164, 2 },
  { "_LEAP_TELEMETRY_DATA", 364, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_TELEMETRY_DATA), offsetof(struct _cffi_align__LEAP_TELEMETRY_DATA, y), 166, 7 },
  { "_LEAP_TRACKING_EVENT", 366, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_TRACKING_EVENT), offsetof(struct _cffi_align__LEAP_TRACKING_EVENT, y), 173, 5 },
  { "_LEAP_TRACKING_MODE_EVENT", 368, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_TRACKING_MODE_EVENT), offsetof(struct _cffi_align__LEAP_TRACKING_MODE_EVENT, y), 178, 2 },
  { "_LEAP_VARIANT", 369, _CFFI_F_PACKED,
    sizeof(LEAP_VARIANT), offsetof(struct _cffi_align__LEAP_VARIANT, y), 180, 5 },
  { "_LEAP_VECTOR", 3, _CFFI_F_PACKED,
    sizeof(LEAP_VECTOR), offsetof(struct _cffi_align__LEAP_VECTOR, y), 185, 4 },
  { "_LEAP_VERSION", 373, _CFFI_F_CHECK_FIELDS|_CFFI_F_PACKED,
    sizeof(LEAP_VERSION), offsetof(struct _cffi_align__LEAP_VERSION, y), 189, 3 },
};

static const struct _cffi_enum_s _cffi_enums[] = {
  { "_eLeapAllocatorType", 262, _cffi_prim_int(sizeof(eLeapAllocatorType), ((eLeapAllocatorType)-1) <= 0),
    "eLeapAllocatorType_Int8,eLeapAllocatorType_Uint8,eLeapAllocatorType_Int16,eLeapAllocatorType_UInt16,eLeapAllocatorType_Int32,eLeapAllocatorType_UInt32,eLeapAllocatorType_Float,eLeapAllocatorType_Int64,eLeapAllocatorType_UInt64,eLeapAllocatorType_Double" },
  { "_eLeapCameraCalibrationType", 376, _cffi_prim_int(sizeof(eLeapCameraCalibrationType), ((eLeapCameraCalibrationType)-1) <= 0),
    "eLeapCameraCalibrationType_infrared,eLeapCameraCalibrationType_visual" },
  { "_eLeapConnectionConfig", 377, _cffi_prim_int(sizeof(eLeapConnectionConfig), ((eLeapConnectionConfig)-1) <= 0),
    "eLeapConnectionConfig_MultiDeviceAware" },
  { "_eLeapConnectionStatus", 378, _cffi_prim_int(sizeof(eLeapConnectionStatus), ((eLeapConnectionStatus)-1) <= 0),
    "eLeapConnectionStatus_NotConnected,eLeapConnectionStatus_Connected,eLeapConnectionStatus_HandshakeIncomplete,eLeapConnectionStatus_NotRunning" },
  { "_eLeapDevicePID", 26, _cffi_prim_int(sizeof(eLeapDevicePID), ((eLeapDevicePID)-1) <= 0),
    "eLeapDevicePID_Unknown,eLeapDevicePID_Peripheral,eLeapDevicePID_Dragonfly,eLeapDevicePID_Nightcrawler,eLeapDevicePID_Rigel,eLeapDevicePID_SIR170,eLeapDevicePID_3Di,eLeapDevicePID_LMC2,eLeapDevicePID_Invalid" },
  { "_eLeapDeviceStatus", 379, _cffi_prim_int(sizeof(eLeapDeviceStatus), ((eLeapDeviceStatus)-1) <= 0),
    "eLeapDeviceStatus_Streaming,eLeapDeviceStatus_Paused,eLeapDeviceStatus_Robust,eLeapDeviceStatus_Smudged,eLeapDeviceStatus_LowResource,eLeapDeviceStatus_UnknownFailure,eLeapDeviceStatus_BadCalibration,eLeapDeviceStatus_BadFirmware,eLeapDeviceStatus_BadTransport,eLeapDeviceStatus_BadControl" },
  { "_eLeapDroppedFrameType", 380, _cffi_prim_int(sizeof(eLeapDroppedFrameType), ((eLeapDroppedFrameType)-1) <= 0),
    "eLeapDroppedFrameType_PreprocessingQueue,eLeapDroppedFrameType_TrackingQueue,eLeapDroppedFrameType_Other" },
  { "_eLeapEventType", 381, _cffi_prim_int(sizeof(eLeapEventType), ((eLeapEventType)-1) <= 0),
    "eLeapEventType_None,eLeapEventType_Connection,eLeapEventType_ConnectionLost,eLeapEventType_Device,eLeapEventType_DeviceFailure,eLeapEventType_Policy,eLeapEventType_Tracking,eLeapEventType_ImageRequestError,eLeapEventType_ImageComplete,eLeapEventType_LogEvent,eLeapEventType_DeviceLost,eLeapEventType_ConfigResponse,eLeapEventType_ConfigChange,eLeapEventType_DeviceStatusChange,eLeapEventType_DroppedFrame,eLeapEventType_Image,eLeapEventType_PointMappingChange,eLeapEventType_TrackingMode,eLeapEventType_LogEvents,eLeapEventType_HeadPose,eLeapEventType_Eyes,eLeapEventType_IMU,eLeapEventType_NewDeviceTransform" },
  { "_eLeapHandType", 382, _cffi_prim_int(sizeof(eLeapHandType), ((eLeapHandType)-1) <= 0),
    "eLeapHandType_Left,eLeapHandType_Right" },
  { "_eLeapIMUFlag", 383, _cffi_prim_int(sizeof(eLeapIMUFlag), ((eLeapIMUFlag)-1) <= 0),
    "eLeapIMUFlag_HasAccelerometer,eLeapIMUFlag_HasGyroscope,eLeapIMUFlag_HasTemperature" },
  { "_eLeapImageFormat", 384, _cffi_prim_int(sizeof(eLeapImageFormat), ((eLeapImageFormat)-1) <= 0),
    "eLeapImageFormat_UNKNOWN,eLeapImageFormat_IR,eLeapImageFormat_RGBIr_Bayer" },
  { "_eLeapImageType", 385, _cffi_prim_int(sizeof(eLeapImageType), ((eLeapImageType)-1) <= 0),
    "eLeapImageType_UNKNOWN,eLeapImageType_Default,eLeapImageType_Raw" },
  { "_eLeapLogSeverity", 386, _cffi_prim_int(sizeof(eLeapLogSeverity), ((eLeapLogSeverity)-1) <= 0),
    "eLeapLogSeverity_Unknown,eLeapLogSeverity_Critical,eLeapLogSeverity_Warning,eLeapLogSeverity_Information" },
  { "_eLeapPerspectiveType", 2, _cffi_prim_int(sizeof(eLeapPerspectiveType), ((eLeapPerspectiveType)-1) <= 0),
    "eLeapPerspectiveType_invalid,eLeapPerspectiveType_stereo_left,eLeapPerspectiveType_stereo_right,eLeapPerspectiveType_mono" },
  { "_eLeapPolicyFlag", 387, _cffi_prim_int(sizeof(eLeapPolicyFlag), ((eLeapPolicyFlag)-1) <= 0),
    "eLeapPolicyFlag_BackgroundFrames,eLeapPolicyFlag_Images,eLeapPolicyFlag_OptimizeHMD,eLeapPolicyFlag_AllowPauseResume,eLeapPolicyFlag_MapPoints,eLeapPolicyFlag_OptimizeScreenTop" },
  { "_eLeapRS", 388, _cffi_prim_int(sizeof(eLeapRS), ((eLeapRS)-1) <= 0),
    "eLeapRS_Success,eLeapRS_UnknownError,eLeapRS_InvalidArgument,eLeapRS_InsufficientResources,eLeapRS_InsufficientBuffer,eLeapRS_Timeout,eLeapRS_NotConnected,eLeapRS_HandshakeIncomplete,eLeapRS_BufferSizeOverflow,eLeapRS_ProtocolError,eLeapRS_InvalidClientID,eLeapRS_UnexpectedClosed,eLeapRS_UnknownImageFrameRequest,eLeapRS_UnknownTrackingFrameID,eLeapRS_RoutineIsNotSeer,eLeapRS_TimestampTooEarly,eLeapRS_ConcurrentPoll,eLeapRS_NotAvailable,eLeapRS_NotStreaming,eLeapRS_CannotOpenDevice,eLeapRS_Unsupported" },
  { "_eLeapRecordingFlags", 389, _cffi_prim_int(sizeof(eLeapRecordingFlags), ((eLeapRecordingFlags)-1) <= 0),
    "eLeapRecordingFlags_Error,eLeapRecordingFlags_Reading,eLeapRecordingFlags_Writing,eLeapRecordingFlags_Flushing,eLeapRecordingFlags_Compressed" },
  { "_eLeapServiceDisposition", 390, _cffi_prim_int(sizeof(eLeapServiceDisposition), ((eLeapServiceDisposition)-1) <= 0),
    "eLeapServiceState_LowFpsDetected,eLeapServiceState_PoorPerformancePause,eLeapServiceState_TrackingErrorUnknown,eLeapServiceState_ALL" },
  { "_eLeapTrackingMode", 104, _cffi_prim_int(sizeof(eLeapTrackingMode), ((eLeapTrackingMode)-1) <= 0),
    "eLeapTrackingMode_Desktop,eLeapTrackingMode_HMD,eLeapTrackingMode_ScreenTop,eLeapTrackingMode_Unknown" },
  { "_eLeapTrackingOrigin", 391, _cffi_prim_int(sizeof(eLeapTrackingOrigin), ((eLeapTrackingOrigin)-1) <= 0),
    "eLeapTrackingOrigin_DeviceCenter,eLeapTrackingOrigin_DevicePrimaryCamera" },
  { "_eLeapValueType", 392, _cffi_prim_int(sizeof(eLeapValueType), ((eLeapValueType)-1) <= 0),
    "eLeapValueType_Unknown,eLeapValueType_Boolean,eLeapValueType_Int32,eLeapValueType_Float,eLeapValueType_String,FORCE_DWORD" },
  { "_eLeapVersionPart", 108, _cffi_prim_int(sizeof(eLeapVersionPart), ((eLeapVersionPart)-1) <= 0),
    "eLeapVersionPart_ClientLibrary,eLeapVersionPart_ClientProtocol,eLeapVersionPart_ServerLibrary,eLeapVersionPart_ServerProtocol" },
  { "eLeapDeviceCaps", 393, _cffi_prim_int(sizeof(enum eLeapDeviceCaps), ((enum eLeapDeviceCaps)-1) <= 0),
    "eLeapDeviceCaps_Color" },
};

static const struct _cffi_typename_s _cffi_typenames[] = {
  { "LEAP_ALLOCATOR", 300 },
  { "LEAP_BONE", 301 },
  { "LEAP_CALIBRATION", 405 },
  { "LEAP_CLOCK_REBASER", 43 },
  { "LEAP_CONFIG_CHANGE_EVENT", 305 },
  { "LEAP_CONFIG_RESPONSE_EVENT", 307 },
  { "LEAP_CONNECTION", 1 },
  { "LEAP_CONNECTION_CONFIG", 308 },
  { "LEAP_CONNECTION_EVENT", 310 },
  { "LEAP_CONNECTION_INFO", 311 },
  { "LEAP_CONNECTION_LOST_EVENT", 313 },
  { "LEAP_CONNECTION_MESSAGE", 314 },
  { "LEAP_DEVICE", 7 },
  { "LEAP_DEVICE_EVENT", 316 },
  { "LEAP_DEVICE_FAILURE_EVENT", 318 },
  { "LEAP_DEVICE_INFO", 319 },
  { "LEAP_DEVICE_REF", 33 },
  { "LEAP_DEVICE_STATUS_CHANGE_EVENT", 321 },
  { "LEAP_DIGIT", 322 },
  { "LEAP_DISTORTION_MATRIX", 326 },
  { "LEAP_DROPPED_FRAME_EVENT", 328 },
  { "LEAP_EYE_EVENT", 330 },
  { "LEAP_FRAME_HEADER", 331 },
  { "LEAP_HAND", 333 },
  { "LEAP_HEAD_POSE_EVENT", 335 },
  { "LEAP_IMAGE", 336 },
  { "LEAP_IMAGE_EVENT", 340 },
  { "LEAP_IMAGE_FRAME_DESCRIPTION", 341 },
  { "LEAP_IMAGE_PROPERTIES", 342 },
  { "LEAP_IMU_EVENT", 344 },
  { "LEAP_LOG_EVENT", 347 },
  { "LEAP_LOG_EVENTS", 349 },
  { "LEAP_MATRIX_3x3", 350 },
  { "LEAP_NEW_DEVICE_TRANSFORM", 352 },
  { "LEAP_PALM", 353 },
  { "LEAP_POINT_MAPPING", 354 },
  { "LEAP_POINT_MAPPING_CHANGE_EVENT", 356 },
  { "LEAP_POLICY_EVENT", 358 },
  { "LEAP_QUATERNION", 359 },
  { "LEAP_RECORDING", 235 },
  { "LEAP_RECORDING_PARAMETERS", 232 },
  { "LEAP_RECORDING_STATUS", 360 },
  { "LEAP_SERVER_STATUS", 361 },
  { "LEAP_SERVER_STATUS_DEVICE", 363 },
  { "LEAP_TELEMETRY_DATA", 364 },
  { "LEAP_TRACKING_EVENT", 366 },
  { "LEAP_TRACKING_MODE_EVENT", 368 },
  { "LEAP_VARIANT", 369 },
  { "LEAP_VECTOR", 3 },
  { "LEAP_VERSION", 373 },
  { "eLeapAllocatorType", 262 },
  { "eLeapCameraCalibrationType", 376 },
  { "eLeapConnectionConfig", 377 },
  { "eLeapConnectionStatus", 378 },
  { "eLeapDevicePID", 26 },
  { "eLeapDeviceStatus", 379 },
  { "eLeapDroppedFrameType", 380 },
  { "eLeapEventType", 381 },
  { "eLeapHandType", 382 },
  { "eLeapIMUFlag", 383 },
  { "eLeapImageFormat", 384 },
  { "eLeapImageType", 385 },
  { "eLeapLogSeverity", 386 },
  { "eLeapPerspectiveType", 2 },
  { "eLeapPolicyFlag", 387 },
  { "eLeapRS", 388 },
  { "eLeapRecordingFlags", 389 },
  { "eLeapServiceDisposition", 390 },
  { "eLeapTrackingMode", 104 },
  { "eLeapTrackingOrigin", 391 },
  { "eLeapValueType", 392 },
  { "eLeapVersionPart", 108 },
};

static const struct _cffi_type_context_s _cffi_type_context = {
  _cffi_types,
  _cffi_globals,
  _cffi_fields,
  _cffi_struct_unions,
  _cffi_enums,
  _cffi_typenames,
  217,  /* num_globals */
  51,  /* num_struct_unions */
  23,  /* num_enums */
  72,  /* num_typenames */
  NULL,  /* no includes */
  415,  /* num_types */
  0,  /* flags */
};

#ifdef __GNUC__
#  pragma GCC visibility push(default)  /* for -fvisibility= */
#endif

#ifdef PYPY_VERSION
PyMODINIT_FUNC
_cffi_pypyinit__leapc_cffi(const void *p[])
{
    p[0] = (const void *)0x2601;
    p[1] = &_cffi_type_context;
#if PY_MAJOR_VERSION >= 3
    return NULL;
#endif
}
#  ifdef _MSC_VER
     PyMODINIT_FUNC
#  if PY_MAJOR_VERSION >= 3
     PyInit__leapc_cffi(void) { return NULL; }
#  else
     init_leapc_cffi(void) { }
#  endif
#  endif
#elif PY_MAJOR_VERSION >= 3
PyMODINIT_FUNC
PyInit__leapc_cffi(void)
{
  return _cffi_init("_leapc_cffi", 0x2601, &_cffi_type_context);
}
#else
PyMODINIT_FUNC
init_leapc_cffi(void)
{
  _cffi_init("_leapc_cffi", 0x2601, &_cffi_type_context);
}
#endif

#ifdef __GNUC__
#  pragma GCC visibility pop
#endif
